<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<link REL="SHORTCUT ICON" HREF="img/favicon.ico">
		<title>dataParser</title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
		<script src="lib/papaparse.min.js"></script>
		<script src="nlp.js"></script>
	</head>
	<style>
		body { 	font-family:Segoe UI,Verdana,Geneva,sans-serif;font-size:16px; margin:20px; }
		.co-is 		{	border-radius:16px; padding:0 8px; height: 24px; border:1px solid #999; font-size: 13px; text-align:center; }
		.co-bs 		{	display:inline-block; border-radius:16px; padding:0 16px; border:1px solid #999; font-size: 13px; 
						cursor:pointer; z-index:2; padding-bottom:1px; color:#000; background-color: #eee; font-weight:600; }
		.co-bsg		{	cursor: pointer; color:#fff; text-align: center; border-radius: 16px; display: inline-block; user-select: none;
						font-size: 13px; background-color: #999; padding: 2px 8px 2px 8px; }
		.lz-confirm {	position: absolute;  width: 300px; padding: 16px; left: calc(50% - 150px); top: calc(50% - 50px); user-select: none;	
						border-radius: 8px; background-color: #fff; border: 1px solid #999; box-shadow: 4px 2px 12px 2px #aaa; }
	</style>
	<body>
		<input type="file" id="lz-tempFile" accept=".csv,.CSV" style="display:none">
		<div class="co-bs" id="lz-importData" style="margin:12px">Load session</div>
		<input type="file" id="lz-testFile" accept=".yml" style="display:none">

		<div style="width:66%;margin:0 auto;text-align:center">
			<img src="img/logo.png" style="width:25%">
			<hr>
			Dataset: <select class="co-is" id="lz-dataset">
				<option>Newdata</option><option>Cleaned</option><option>Original</option>><option>Testdata</option>
				</select>
			&nbsp &nbsp; Series: <select class="co-is" id="lz-series">
				<option>Hundreds</option><option>Tens</option><option>Decimals</option><option>
			</select>
			&nbsp &nbsp; Max per intent: <input type="input" class="co-is" style="width:40px" value="500" id="lz-num"/>
			&nbsp &nbsp; Test % <input type="input" class="co-is" style="width:40px" value="0" id="lz-holdOut"/>
			<hr><p>
				<div class="co-bs" id="lz-makeTrain">Make nlu.yml</div>
				&nbsp; &nbsp; &nbsp;<div class="co-bs" id="lz-testData">Test data</div>
				&nbsp; &nbsp; &nbsp;<div class="co-bs" id="lz-makeSession">Make session</div>
				&nbsp;<input type="input" class="co-is" style="width:40px" value="78" id="lz-session"/>
			</p>
			<hr>
			<p id="outp" style="text-align:left"></p>
		</div>
	
<script>

/////////////////////////////////////////////////////////////////////////////////////////////////
// APP 
/////////////////////////////////////////////////////////////////////////////////////////////////

	let rawData=[], intents=[], session=[], keyWords=[], vocab=[]; uvocab=[];
	let nlp=new NLP();																				// Alloc NLP class
	let ws=null;																					// Socket server				
	let aiType="rasa";																			// AI type																																			

	$(document).ready(function() {								           						// ON PAGE LOADED
		LoadConfig();																				// Load config file
		InitSocketServer();
		$("#lz-makeTrain").on("click",()=>	  { MakeStories(1);    } );								// ON MAKE NLU ILE
		$("#lz-makeSession").on("click", ()=> { MakeSession();     } );								// ON MAKE SESSION
		$("#lz-testData").on("click", ()=> 	  { $("#lz-testFile").trigger("click"); 	});			// ON TEST DATA
		$("#lz-importData").on("click",()=>   { $("#lz-tempFile").trigger("click"); 	});			// ON IMPORT
		$("#lz-dataset").on("change", ()=>    { LoadConfig($("#lz-dataset").val()) 		});			// ON DATASET
				
		$("#lz-tempFile").on("change",(e)=>{														// ON FILE LOAD
			ImportCSV(e);																			// Read file
			$("#lz-tempFile").val("");																// Clear value		
			});
		$("#lz-testFile").on("change",(e)=>{														// ON TEST FILE LOAD
			TestData(e,aiType);																		// Read file
			$("#lz-tempFile").val("");																// Clear value		
			});
		$(window).on("keydown",function(e) {														// HANDLE KEYPRESS
			if ((e.which == 81) && e.ctrlKey)	{										// Test key (CTL-Q)
				Test500s();
				}
			});
	});

	function LoadConfig(dataset="Newdata")														// LOAD CONFIG FILE
	{	
		let i;
		rawData=[]; intents=[]; keyWords=[]; vocab=[];												// Reset
		fetch('data/config-1.csv')																	// Load file
			.then(res => res.text())																// Get as text
			.then(res =>{																			// Process																	
				let d=Papa.parse(res, { header:true, skipEmptyLines:true }).data;					// Parse CSV using papa lib
				for (i=0;i<d.length;++i) 															// For each line
					 nlp.AddSyns(d[i].type,d[i].id,d[i].text.split(",")); 							// Add synonyms, keywords, keytags, vocab
				LoadRawData("data/"+dataset+".csv");												// Load raw data file
			});
		}
	
	function LoadRawData(file)																	// LOAD RAW DATA CSV
	{
		fetch(file)																					// Load file
			.then(res => res.text())																// Get as text
			.then(res =>{																			// Process																	
				rawData=Papa.parse(res, { header:true, skipEmptyLines:true }).data;					// Parse CSV using papa lib
				GetKeyWords();																		// Get keywords
				ParseData();																		// Parse data and show stats
			});
	}

	function ParseData()																		// PARSE DATA AND SHOW DATA STATS
	{
		let i,o,kill;
		let nRemarks=0, nResponses=0; 																// Counts
		for (i=0;i<rawData.length;++i) {															// For each entry
			kill=0;																					// Assume we keep it
			o=rawData[i];																			// Point at line
			o.text=nlp.CleanText(o.text);															// Clean text
			if (o.speaker == "Teacher") {															// A remark
				if (o.text.split(" ").length < 4)	continue;										// Skip short remarks
				if (!o.clean_intent)				o.text=nlp.CleanText(o.text);					// No flag set
				else if (o.clean_intent <= 0)		{ rawData.splice(i,1); continue; }				// Remove bad remark
				else if (o.clean_intent == 1)		o.text=nlp.CleanText(o.clean_text);				// Get cleaned text			
				else if (o.clean_intent == 2)		o.text=nlp.CleanText(o.revised);				// Get revised text			
				++nRemarks;																			// Add to count											
				if (!intents["r"+Math.floor(o.intent)]) intents["r"+Math.floor(o.intent)]=[];		// Create base intent holder
				if (!intents["r"+o.intent]) intents["r"+o.intent]=[];								// Create full holder
				intents["r"+Math.floor(o.intent)].push(i);											// Add base index
				intents["r"+o.intent].push(i);														// Add full
				}
			else{																					// A student response
				++nResponses;																		// Add response
				}
			}
		
		let str=`<table>
		<tr><td><b>Number of remarks</b>:</td><td>${nRemarks}</td></tr>
		<tr><td><b>Number of responses</b>: &nbsp; </td><td>${nResponses}</td></tr>`
		str+=getIntents()+"</table>";																// Get number of intents
		$("#outp").html(str.replace(/\t|\n|\r/g,""));												// Show stats

		function getIntents() {																		// GET INTENTS
			let i,j,s="";
			for (i=0;i<1000;i+=10) 																	// For each intent
				if (intents["r"+i]) 																// If it exists	
					s+=`<tr><td><b>Intent ${i}</b>:</td><td>${intents["r"+i].length}</td><td>${getSubIntents(i)}</td></tr>`;
			return s;																				// Return intent line
			}

		function getSubIntents(base) {																// GET NUMBER OF SUB INTENTS
			let i,s="( &nbsp;";
			for (i=1;i<10;++i) 																		// For for subs
				if (intents["r"+base+"."+i]) 														// If it exists	
					s+=i+"="+intents["r"+base+"."+i].length+" &nbsp;";								// Add to string
			return s+")";																			// Return subs
			}
	}		

	function GetKeyWords()																		// GET UNIQUE LIST OF WORDS
	{
		let i,j,k,v,s;
		keyWords=[];																				// Clear array
		for (i=0;i<rawData.length;++i) {															// For each line
			if (!rawData[i].text) continue;															// Nothing there
			v=nlp.Tokenize(rawData[i].text);														// Clean and tokenize line
			for (j=0;j<v.length;++j) 																// For each word															
				keyWords.push(v[j]);																// Add to key word list	
			}
		keyWords=[... new Set(keyWords)];															// Make unique

		for (k=100;k<600;k+=100) {																	// Top series
			vocab["r"+k]=[];																		// Start fresh
			for (i=0;i<rawData.length;++i) {														// For each line
				if (!rawData[i].text)										continue;				// Nothing there
				if (rawData[i].speaker != "Teacher") 						continue;				// Only teachers
				if (Math.floor(Math.floor(rawData[i].intent/100)*100) != k) continue;				// Only this intent's 100s level
				v=nlp.Tokenize(rawData[i].text.toLowerCase());										// Tokenize line
				for (j=0;j<v.length;++j)  if (v[j].length > 4) vocab["r"+k].push(v[j]);				// Add to key word list	
				}
			vocab["r"+k]=[... new Set(vocab["r"+k])];												// Make unique
			}
return;
		uvocab=[];
		uvocab["r500"]=vocab["r500"].filter(x => ![...vocab["r100"],...vocab["r200"],...vocab["r300"],...vocab["r400"]].includes(x));
		uvocab["r400"]=vocab["r400"].filter(x => ![...vocab["r100"],...vocab["r200"],...vocab["r300"],...vocab["r500"]].includes(x));
		uvocab["r300"]=vocab["r300"].filter(x => ![...vocab["r100"],...vocab["r200"],...vocab["r400"],...vocab["r500"]].includes(x));
		uvocab["r200"]=vocab["r200"].filter(x => ![...vocab["r100"],...vocab["r300"],...vocab["r400"],...vocab["r500"]].includes(x));
		uvocab["r100"]=vocab["r100"].filter(x => ![...vocab["r200"],...vocab["r300"],...vocab["r400"],...vocab["r500"]].includes(x));
		}
	
	async function TestData(e,aiType)																	// TEST DATA
	{	

//		TrainWit(e);	return;

		let i,k,o,v,id,str;
		let file=e.target.files[0];																	// Point at file
		if (!file) 	return;																			// Quit if bad
		let reader=new FileReader();																// Init reader
		reader.readAsText(file);																	// Read file
		reader.onload=(e)=>{ 																		// When loaded
			LoadingIcon(true);																		// Show loading icon
			let nums=[]; nums["*100"]=0; nums["*200"]=0; nums["*300"]=0;	nums["*400"]=0;	nums["*500"]=0;	
			let oks=[];  oks["*100"]=0; oks["*200"]=0;	oks["*300"]=0;	oks["*400"]=0;	oks["*500"]=0	;
			let tots=[],report=[],msgs=[];
			v=e.target.result.split("\n");															// Divide by LF
			for (i=0;i<v.length;++i) {																// For each line
				if (!v[i]) 						continue;											// Skip is nothing there
				if (v[i].match(/- intent: r/))	k=v[i].substr(11).trim();							// Get series
				if (v[i].match(/^   /)) 		msgs.push({ text:v[i].substr(5), intent:k });		// Add if an example
				}
			let tot=msgs.length;																	// Get total to detect
			InferIntents(msgs,aiType,(res)=>{ 														// On each inference
				trace(res)
				id=res.intent;																		// Get id	
				nums["*"+Math.floor(id/100)*100]++;													// Advance total count at 100 level
				if (Math.floor(id/100)*100 == Math.floor(res.labeled/100)*100)	oks["*"+Math.floor(id/100)*100]++;	// Add if a match at 100 level
				$("#lz-loadingIconText").html("<b>"+(100-Math.floor(msgs.length/tot*100))+"%</b>");	// Show progress
				str=id+"\t";																		// Coded intent
				str+=(id == res.labeled) ? "   " : " X ";											// Right or wrong?
				str+="\t"+res.labeled;																// Labeled intent
				str+="\t | \t"+res.text;															// Text
				report.push(str);																	// Add to report
				if (!msgs.length) {																	// If last one
					tots["*100"]=oks["*100"]+"/"+nums["*100"]+"="+Math.floor(oks["*100"]/nums["*100"]*100)+"%"; // 100s tally
					tots["*200"]=oks["*200"]+"/"+nums["*200"]+"="+Math.floor(oks["*200"]/nums["*200"]*100)+"%";	// 200s
					tots["*300"]=oks["*300"]+"/"+nums["*300"]+"="+Math.floor(oks["*300"]/nums["*300"]*100)+"%";	// 300s
					tots["*400"]=oks["*400"]+"/"+nums["*400"]+"="+Math.floor(oks["*400"]/nums["*400"]*100)+"%";	// 400s
					tots["*500"]=oks["*500"]+"/"+nums["*500"]+"="+Math.floor(oks["*500"]/nums["*500"]*100)+"%";	// 500s
					Sound("ding");																	// Ding				
					LoadingIcon(false);																// Hide loading icon
					report.sort(); 																	// Sort
					trace(report.join("\n"));														// Show repoport
					trace(tots);																	// Show results
					trace(nums,oks)
					}
				});
			};
	}

	let df={ key:"-----BEGIN PRIVATE KEY-----\nMIIEvAIBADANBgkqhkiG9w0BAQEFAASC-X-BKYwggSiAgEAAoIBAQDIyWCZN4wQuQio\noIeCoXzIwwLvS5Q55HKo-X-w/xMqm5mXntySbZ/DnSFis5Nca/emZx9YAc1DpiMil/t\neyOhPseFWx77riq9YqnACKMxfeeADUEJTof+OOxJ/d+bJEDmyN/zAfGHOYCmzdea\nBB9LWgfegeSpN7pmHudtdy/4geNuwBcGV5VMJfrp1rvwGlPBi0jSisQ7y0oaBDbl\ntHB8zbqGfHi5usq87ghy8V1Ax3pilp+DcnSN+84h/tgQGeDh8p4nnXXTACCvQc30\nbmaMbDEuBEikoPjzRxTozPQblp910QvsAaIG7KQb+5hEb5jHjGrDbNUqIkfshKQj\nkW897VatAgMBAAECggEAQgz06RI70lh8P7SnP1LOUODN+1g6h5zeFyR5v+Kk9KoK\nI/uZvExOCowx94n5l9migB/x3wNRLZJrohzLCMU1L2pdU9/kkW5+dvygaqyHVjmF\n9oDN/dRN7r1ELK4NZ54XBcLS6HADIVw/m5vVi50vT4Qda4k4mVV7PihiMHbSEWEs\nOpnMpoIwNgMY3iTWN+fD113xrdkVwEZ9ZeWmvblizaEzjEUhLBGfkpX8huBmFon8\nCb/hTuNFP4IIxXv9O2w88x4NgF+8hB4cAP8rS7R3Hs6mpcQhlSJpYKZZFduNFKPE\nAFH3p1A7ooj+dKePawJhg/kti91jkFzC+JzzZAUKZQKBgQDou8xlf5WeDiXfiOHK\nIHNoFTxTFjJzMItxhrlKZr5WFeI8zryZ0Kcnd4JCw+vhYhPkS2UCieOPSm04oD8o\nTO/1xqRR1sYtpgBQmPzdAzoSU+70r3P3E4USAmSo8SYCNGrwjWGcB36bVQzldSoy\nNE/XGVZ6C1j2MPQ7dGO7JaaclwKBgQDc2/scmz1XHtY+MqUBgRqWmB5NeomP2fL2\nXDOs2BwjoRXnWtRscmmUfylvYR6/baKtr3BJgNohAR0t4D+S1yIe1WC5tFL4Um4l\n13gu9aW+WHEBNkYbC2uJMtulBFDHnvuWBOoYoBd4eGlWWRK+YScgHEl4EcvtMfW0\nlLkrDYZbWwKBgGVZwz1APmvCRYP/HDTlxNxCwy57sCSxs0gRH4fjDmh2xzsr3L4v\nO1vYk4V3xLU1/OuiWa6tVcgE5WOPhXGLb8RcaRqqqUsfy2tN9HBbA2MP4jP0ZE/o\n1D5vhF5+BctYAGoZZ7SHHv+OHjuetm1+knZdtmcXofo0f2eU3AmX7+KpAoGASleR\n0zM+FpE+tHj/qd33QTG7IYFZxJ4sdlja3BdygVu7r8CXOFnayC11mRQr8WvKEoS3\nW0aQJgPl+oc9XwQjbBWPFXNpakT05q/8uHHfdI74mtvWBUx2yhvga09kkY0mSn0k\n/10ECX0el/4rnQG+1cQvxsbWyeTDPCHDooZO73kCgYAMprTRXFc3IkT82cwfcWmY\n6TzfzmWmqxR41fjORQqr6bh/8B8GHvAXdl2DeKw6SoUl+CLylA2ucAuFmq70+m8i\nR6922rx3ThmaPBUlN//i2a-X-RYyHRbERwTJ0q2Gmw35qhfKGzhrML3pHjtjJmSpYp1\np0yznBeNUd/Dekkm-X-NNhrHQ==\n-----END PRIVATE KEY-----\n",
			 email:"liza100s@liza-100s-mmhi.iam.gserviceaccount.com",
			 id: "liza-100s-mmhi"
			}
	async function InferIntents(msgs, aiType, callback)											// GET RESPONSE FROM AI
	{
		try {
		let m=msgs.shift();																			// Remove from list
		let inference={ text:m.text, labeled:m.intent, intent:0, confidence:0 };					// Null inference
		if (aiType == "rasa") {																		// If RASA
			const response=await fetch("https://lizasim.com:5005/model/parse", {					// Fetch data
				method:"POST",																		// POST
				body: JSON.stringify({text:m.text})													// Payload	
				});
			let res=await response.json();															// Get response 
			inference.intent=res.intent.name.substr(1);												// Intent																		
			inference.confidence=res.intent.confidence;												// Confidence
			inference.labeled=m.intent;																// Labeled intent
			callback(inference);																	// Return inference object
			if (msgs.length) InferIntents(msgs, aiType, callback)									// Recurse, if not last
			}
		else if (aiType == "dialog") {																// If DIALOGFLOW
			let p=new Promise((resolve, reject) => {
				setTimeout(()=>{ws.send("1|DIALOGFLOW|ADMIN|INFER|"+df.id+"|"+df.email+"|"+df.key+"|"+m.text.substring(0,255))},500);
				ws.onmessage=(e)=>{ 																// If a ws message
					if (!e.data)			 return;												// Quit if no data
					let v=event.data.split("|");													// Get params
					if (v[1] != "DIALOGFLOW") return;												// Not a dialogflow inference
					resolve(v) };																	// Resolve promise
				}).then(res =>{ 																	// On resolution
					inference.intent=res[2].substr(1);												// Intent																		
					inference.confidence=res[3];													// Confidence
					callback(inference); 															// Return inference
					if (msgs.length) InferIntents(msgs, aiType, callback)							// Recurse, if not last
					});
			}
		else if (aiType == "wit") {																	// If WIT
			let url="https://api.wit.ai/message?v=20210922&q="+m.text.substring(0,255);				// URL
			let token="JIZ-X-ALYOUZC-X-P3ALOLFY45EFM-X-3I5RUJQC3".replace(/-X-/g,"");				// Get sever token 100s
//			let token="5BVRE-X-PNGZ6AKO-X-EA7P44KU3-X-PXU7LRKVVD".replace(/-X-/g,"");				// Get token 10s
//			let token="SOYJDBYI5WSJB-X-VBCEQZ2CHSWNZ-X-2KYN4U".replace(/-X-/g,"");					// Get token 10 w/ 100 per intent
			
			const response=await fetch(url, { headers:{ Authorization:'Bearer '+token, 'Content-Type':'application/json'} });	// Send remark to wit
			let res=await response.json();															// Get response
			if (res.intents.length) {																// If an intent found
				inference.intent=res.intents[0].name.substr(1);										// Get intent																		
				inference.confidence=res.intents[0].confidence;										// Confidence
				}	
			callback(inference);																	// Return response
			if (msgs.length) setTimeout(()=>{ InferIntents(msgs, aiType, callback);},1000);			// Recurse, if not last and add delay
			}
		} catch(e) {trace(e)}
	} 

	function InitSocketServer()																	// INIT SOCKET SERVER
	{
		if (window.location.host == "localhost") ws=new WebSocket('ws://'+window.location.host+':8080');	// Open insecure websocket											
		else									 ws=new WebSocket('wss://'+window.location.host+':8080');	// Secure											
		ws.onclose=()=>   { console.log('disconnected'); ws=null; Sound("delete") };				// ON CLOSE
		ws.onerror=(e)=>  { console.log('error',e);	};												// ON ERROR
		ws.onopen=()=> 	  { console.log('connected'); };											// ON OPEN
	}
	
/////////////////////////////////////////////////////////////////////////////////////////////////
// OUTPUT 
/////////////////////////////////////////////////////////////////////////////////////////////////

	function FindPreviousResponse(ind)															// GET PREVIOUS STUDENT RESPONSE
	{
		while (--ind >= 0) {																		// Search backwards
			if (rawData[ind].speaker != "Teacher") 													// If not a teacher
				return rawData[ind].text;															// Return previous response
			}
		return "";																					// No previous response
	}

	function MakeStories(mask)																	// MAKE ALL FILES
	{
		let ints=[],doms=[],sess=[],dupes=[];
		let rType,keys=[],resps=[];
		let i,inc,o,c,ss,re,who,id,sid,tot;
		let test=$("#lz-holdOut").val()/100;														// Percent to test
		let level=$("#lz-series").val();															// Level of intents
		let num=$("#lz-num").val();																	// Max per intent
		
//		ints["bot_challenge"]=[]; 	 ints["addition"]=[]; 											// Built-ins
//		ints["bot_challenge"].push("    - are you a bot?"); ints["bot_challenge"].push("    - are you human?");
//		ints["bot_challenge"].push("    - am I talking to a bot?"); ints["bot_challenge"].push("    - am I talking to a human?");
//		ints["addition"].push("    - what is 2+2?"); ints["addition"].push("    - what does 2+2 equal?"); ints["addition"].push("    - what does 2+2 make?"); 
		
		for (i=0;i<rawData.length;++i) {															// For each line
			o=rawData[i];																			// Point at it
			if ((o.intent < 180) || ((o.intent > 181) && (o.intent < 250))) continue;				// Cull 0-250
//			if ((o.intent < 100) || ((o.intent > 179) && (o.intent < 210))) continue;				// Cull 181-210
			if (nlp.Tokenize(o.text).length < 4)			continue;								// Skip if short
			if (level == "Decimals") 		id=o.intent;											// Make full intent id name
			else if (level == "Tens")		id=Math.floor(o.intent);								// Cap at 10s					
			else							id=Math.floor(o.intent/100)*100;						// Cap at 100s
			
			sid="session-"+o.rerid;																	// Session id
			if (!sess[sid]) 			  	sess[sid]=[];											// Alloc session holder
			if (o.speaker == "Teacher") {															// If remark
				keys=nlp.Tokenize(o.text).filter(value => keyWords.includes(value));				// Get keys mentioned
				if (id < 100)	continue;															// Skip if uncoded
				id="r"+id;																			// Prefix id
				if (!ints[id]) ints[id]=[];															// Alloc intent holder
				sess[sid].push("  - intent: "+id+"\n");												// Add intent to story
				ss=nlp.CleanRemark(o.text,FindPreviousResponse(i));									// Get clean text
				who=nlp.GetWho(o.text);																// Get who
				ints[id].push("    - "+ss.trim());													// Add it
				} 
			else{																					// Response
				rType="agree";
				if (isNaN(id)) {																	// Ignore numbered responses for now
					resps.push( { intent:id,text: o.text.trim().replace(/:|"/g,""),keys:keys,type:rType,turn:Math.floor(i/2),speaker:who.split(":")[1] });
					sess[sid].push("  - action: utter_r"+i+"\n");									// Add response to story
					doms.push(`\n  utter_r${i}:\n  - text: "${o.text.trim().replace(/:|"/g,"")}"\n`);	// Add to domain file
				}
			}
		}

		for (k in ints)	ints[k]=[... new Set(ints[k])];												// Make unique																		// For each intent
		let str="version: \"3.0\"\n\nnlu:\n";														// NLU header
		let v=[],j,str2=str;		
		for (k in ints)	v.push(k);																	// Make normal array of intents
		v=v.sort();																					// Sort them
		for (j=0;j<v.length;++j)	{																// For each intent
			k=v[j];																					// intent name
			tot=Math.floor(Math.min(num,ints[k].length)*(1-test));									// Get amount to train
			inc=Math.max(ints[k].length/num,1);														// Sampling increment, at least 1
			str+="- intent: "+k+"\n  examples: |\n";												// Add header
			str2+="- intent: "+k+"\n  examples: |\n";												// Add header
			for (i=0;i<tot*inc;i+=inc) 																// For each one wanted
				str+=ints[k][Math.floor(i)]+"\n";													// Get it
			for (i=0;i<Math.min(num,ints[k].length)-tot;++i) 										// For each test example
				str2+=ints[k][Math.floor(i+tot)]+"\n";												// Get it
			}
		if (mask&1) 			  SaveTextAsFile("nlu.yml",str);									// Write training file
		if (mask&1 && (test > 0)) SaveTextAsFile("test.yml",str2);									// Write testing file
/*		DIALOGFLOW	
		
		for (j=0;j<v.length;++j) {																// For each intent
			str="[\n";
			k=v[j];																					// intent name
			tot=Math.floor(Math.min(num,ints[k].length)*(1-test));									// Get amount to train
			inc=Math.max(ints[k].length/num,1);														// Sampling increment, at least 1
			for (i=0;i<tot*inc;i+=inc) {															// For each one wanted
				ss=ints[k][Math.floor(i)].slice(6,-1);												// Remove yaml header
				ss=ss.replace(/"/g,"");																// No quotes
				ss=ss.replace(/'/g,"\\u0027");														// Escape apos
				str+=`{ "data": [{ "text": "${ss}", "userDefined": false }], "isTemplate": false, "count": 1, "lang": "en", "updated": 0 },\n`;
				}
			str=str.slice(0,-2)+"\n]";
			SaveTextAsFile(k.substr(1)+"_usersays_en.json",str);													// Write file
		}
*/

	Test500s(ints);
	}

	async function MakeSession()																// CREATE SESSION FILE
	{
		let i=0,o,n=rawData.length,data=[];
		let speaker,remark="",response="",intent,student;
		while (i < n) {																				// For each item
			o=rawData[i++];																			// Point at line
			if (o.speaker == "Teacher") {															// If a teacher
				if (!o.intent) continue;															// Skip uncodeds
				remark+=o.text+" ";																	// Add remark
				intent=o.intent;																	// Set last intent
				}				
			else{																					// A student
				--i;
				while (i < n) {																		// Collect all responses
					o=rawData[i];																	// Point at line
					if (o.speaker == "Teacher") break;												// Quit at next remark
					response+=o.text+" ",student=o.speaker;											// Add response and set last student
					++i;																			// Advance
					}
				data.push({ id:o.id,intent:intent,student:student,code:"",remark:remark,response:response} );	// Add to data
				remark=response="";
				}
			}
		let fields=["id","intent","student","remark","response"];							// Field names
		let str=Papa.unparse(data,{ header:true, skipEmptyLines:true, columns:fields });			// Make CSV using lib
		SaveTextAsFile("session.csv",str);														// Write file
		Sound("ding");																				// Sound
	}

	function GetResponse(msg)																	// GET RESPONSE FROM AI
	{
		return fetch("https://lizasim.com:5005/model/parse", {										// Fetch data
			method:"POST",	
			body: JSON.stringify({text:msg})		
			})
	}

	function ImportCSV(e) {																		// IMPORT SESSION FROM CSV
		let i,d="";
		let file=e.target.files[0];																	// Point at file
		if (!file) 	return;																			// Quit if bad
		let reader=new FileReader();																// Init reader
		reader.readAsText(file);																	// Read file
		reader.onload=(e)=>{ 																		// When loaded
			let csv=Papa.parse(e.target.result, { header:false, skipEmptyLines:true }).data;		// Parse CSV using papa lib
			for (i=0;i<csv.length;++i) {															// For each line
				if (csv[i][8] == "Teacher")	{														// Only remarks
					if (csv[i][11] == "1") 		s=csv[i][11];										// Original correction
					else if (csv[i][11] == "2") s=csv[i][13];										// Double correction
					else						s=csv[i][10];										// No correction, use original
					if (s.length < 4)			continue;											// Skip if too short
					s=nlp.CleanRemark(s);															// Make line	
					d+="    - "+s+"\n";																// Add
					}
				}
			trace(d)
			Sound("ding");																			// Ding
			};
	}

//
///////////////////////////////////////////////////////////////////////////////////////////////
// WIT
/////////////////////////////////////////////////////////////////////////////////////////////////

	async function TrainWit(e)																	// TRAIN WIT
	{	
		let i,v,msgs=[];
		let file=e.target.files[0];																	// Point at file
		if (!file) 	return;																			// Quit if bad
		let reader=new FileReader();																// Init reader
		reader.readAsText(file);																	// Read file
		reader.onload=(e)=>{ 																		// When loaded
			LoadingIcon(true);																		// Show loading icon
			v=e.target.result.split("\n");															// Divide by LF
			for (i=0;i<v.length;++i) {																// For each line
				if (!v[i]) 						continue;											// Skip is nothing there
				if (v[i].match(/- intent: r/))	k=v[i].substr(11).trim();							// Get series
				if (v[i].match(/^   /)) 		msgs.push({ text:v[i].substr(5), intent:k });		// Add if an example
				}
			let tot=msgs.length;																	// Get total to train
			WitTrain(msgs, (r1,r2)=>{																// Start sending via recursion		
				trace(r1,r2);																		// Log	
				$("#lz-loadingIconText").html("<b>"+(100-Math.floor(msgs.length/tot*100))+"%</b>");	// Show progress
				if (!msgs.length) {																	// If last one
					Sound("ding");																	// Ding				
					LoadingIcon(false);																// Hide loading icon
					}
				});											
			};
	}
	
	async function WitTrain(msgs, callback)														// SEND REMARK TO WIT TO TRAIN
	{
		let inference={ text:"", intent:0, confidence:0 };											// Null inference
		let m=msgs.shift();																			// Remove from list and save first
		const url="https://api.wit.ai/utterances?v=20210922";										// URL 
		let token="JIZ-X-ALYOUZC-X-P3ALOLFY45EFM-X-3I5RUJQC3".replace(/-X-/g,"");					// Get sever token 100s
//		let token="5BVRE-X-PNGZ6AKO-X-EA7P44KU3-X-PXU7LRKVVD".replace(/-X-/g,"");					// Get token 10s
//		let token="SOYJDBYI5WSJB-X-VBCEQZ2CHSWNZ-X-2KYN4U".replace(/-X-/g,"");						// Get token 10 w/ 100 per intent
		let body=[{ text:m.text.substring(0,255), intent:"r"+m.intent, entities:[], traits: [] }];	// Make body
		const response=await fetch(url, { 															// Send remark to wit
			  method:"POST",
			  headers: { Authorization:'Bearer '+token, 'Content-Type':'application/json'}, 
			  body: JSON.stringify(body)
			  });	
		let res=await response.json();																// Get response
		callback(m,res);																			// Return responss
		if (msgs.length) setTimeout(()=>{ WitTrain(msgs, callback) },500);							// Recurse, if not last
	}

/*

{
  "queryParams": {
    "sentimentAnalysisRequestConfig": {
      "analyzeQueryTextSentiment": true
    }
  },
  "queryInput": {
    "text": {
      "text": "please reserve an amazing meeting room for six people",
      "languageCode": "en-US"
    }
  }
}
	function OAIGet(msg)																	// GET RESPONSE FROM AI
	{
		let body={
		"prompt": "The following is a list of companies and the categories they fall into\n\nFacebook: Social media, Technology\nLinkedIn: Social media, Technology, Enterprise, Careers\nUber: Transportation, Technology, Marketplace\nUnilever: Conglomerate, Consumer Goods\nMcdonalds: Food, Fast Food, Logistics, Restaurants\nFedEx:",
		"temperature": 0,
		"max_tokens": 6,
		"top_p": 1.0,
		"frequency_penalty": 0.0,
		"presence_penalty": 0.0,
		"stop": ["\n"]
		}

		const url="https://api.openai.com/v1/engines/davinci/completions"
		let token="sk-u4nGW65-X-gajLxEDQlh9OTT3BlbkF-X-JHp7xp1JaQ5HJT7Ca3pqs".replace(/-X-/g,"");	// Get token
		fetch(url,{ method:"POST",
			  headers: { Authorization:'Bearer '+token, 'Content-Type':'application/json'}, 
			  body: JSON.stringify(body)
			  })	
	  	.then(res => res.json()).then(res =>{ trace(res); })
	}
*/
/////////////////////////////////////////////////////////////////////////////////////////////////
// HELPERS 
/////////////////////////////////////////////////////////////////////////////////////////////////

	function trace(msg, p1, p2, p3, p4)																// CONSOLE 
	{
		if (p4 != undefined)
			console.log(msg,p1,p2,p3,p4);
		else if (p3 != undefined)
			console.log(msg,p1,p2,p3);
		else if (p2 != undefined)
			console.log(msg,p1,p2);
		else if (p1 != undefined)
			console.log(msg,p1);
		else
			console.log(msg);
	}

	function Sound(sound, mute)																		// PLAY SOUND
	{
		var snd=new Audio();																			// Init audio object
		if (sound.match(/\.mp3/i))		snd=new Audio(sound)											// If an MP3 file
		else							snd=new Audio("img/"+sound+".mp3");								// Use built in mp3
		if (!mute)	{																					// If not initing or muting	
			snd.volume=100/100;																			// Set volume
			snd.play();																					// Play it
			}
		}

	function SaveTextAsFile(file, contents)															// SAVE TEXT TO LOCAL FILE
	{
		if (file.charAt(0) == "*") {																	// If asking
			GetTextBox("Type file name","", file.substr(1), (s)=>{ SaveTextAsFile(s, contents); });		// Ask for name
			return;																						// Quit
			}
		var textFileAsBlob=new Blob([contents], {type:'text/plain'});
		var downloadLink=document.createElement("a");
		downloadLink.download=file;
		downloadLink.innerHTML="Download File";
		downloadLink.href=window.URL.createObjectURL(textFileAsBlob);
	    downloadLink.onclick=()=>{ downloadLink.remove(); };
		downloadLink.style.display="none";
		downloadLink.id="tdll";
		document.body.appendChild(downloadLink);
		downloadLink.click();
	}

	function GetTextBox(title, content, def, callback)											// GET TEXT LINE BOX
	{
		$("#confirmBoxDiv").remove();																	// Remove 
		$("body").append("<div class='lz-confirm' id='confirmBoxDiv'></div>");							// Add box								
		var str="<img src='img/smlogo.png' width='64' style='vertical-align:-8px'/>&nbsp;&nbsp;";								
		str+="<span style='font-size:14px; color:#666'><b>"+title+"</b></span><br><br>";
		str+="<p>"+content+"<p>";
		str+="<p><input class='lz-is' style='width:75%' type='text' id='gtBoxTt' value='"+def+"'></p>";
		str+="<div id='dialogOK' class='lz-bs'>OK</div>";
		str+="<div id='dialogCancel' class='lz-bs' style='margin-left:8px;background-color:#999'>Cancel</div></div>";
		$("#confirmBoxDiv").html(str);																	// Add to div
		$("#gtBoxTt").focus();																			// Focus on button
		$("#gtBoxTt").on("change", function() {	callback($("#gtBoxTt").val()); $("#confirmBoxDiv").remove(); });	// ONE ENTER
		$("#dialogOK").on("click", function() {	callback($("#gtBoxTt").val()); $("#confirmBoxDiv").remove(); });	// ON OK 
		$("#dialogCancel").on("click", function() {	$("#confirmBoxDiv").remove(); });								// ON CANCEL
		}

	function TimecodeToSeconds(timecode) 														// CONVERT TIMECODE TO MILLISECONDS
	{
		if (!timecode)	return 0;
		let t=0;
		let v=timecode.match(/(\d*):(\d*):(\d*)\.*(\d*)/);											// Parse
//		t+=v[1]*60*60*1000;																			// Get hours
		t+=v[2]*60*1000;																			// Get mins
		t+=v[3]*1000;																				// Get secs
		if (v[4]) t+=v[4]/1000;																		// Ms
		return t;																					// Return time in ms
	}

	function LoadingIcon(mode)																	// SHOW/HIDE LOADING ICON		
	{
		if (!mode) {																				// If hiding
			$("#lz-loadingIcon").remove();															// Remove it
			return;																					// Quit
			}
		let str="<div id='lz-loadingIcon' style='position:absolute;top:calc(50% - 64px);left:calc(50% - 64px);z-index:5000;text-align:center'>";
		str+="<img src='img/loading.gif' width='128'>";												// Img
		str+="<div id='lz-loadingIconText' style='margin-top:-78px;color:#999'></div></div>";		// Progress
		$("body").append(str);																		// Add icon to container
	}

/////////////////////////////////////////////////////////////////////////////////////////////////
// KEYS / VOCAB
/////////////////////////////////////////////////////////////////////////////////////////////////
	let keySyns=[];
	MakeActionKeys()

	function MakeActionKeys()
	{
		let i,v;
		v=(`strategy,strategies,policy,policies,procedure,procedures,approach,approaches,approaching,blueprint,program,stratagem,stratagems,
		plan,plans,planning,guideline,guidance,scheme,schema,organize,organization,tenet,path,pathway,avenue,agenda,agendas,agendum,channel,channels,modus,operandi,maneuver,
		process,prototype,archetype,model,theory,theories,structure,structures,arrange,arrangement,arranging,classify,classification,clue,incorporate,integrate,
		sort,proposal,propose,codify,codification,layout,design,designs,coordinate,create,creating,created,establish,standardize,figured,skill,skills,
		rule,rules,construct,constructs,constructed,constructing,invent,technique,progression,unfolding,architecture,catalog,catalogue,alphabetize,pattern,
		method,manner,mechanism,rubric,routine,scenario,outline,synopsis,summary,summarize,rundown,run-down,review,recap,recapitulation,
		analysis,keyword,keywords,key_word,sequence.chronological,timeline,concept,concepts,conceptualize,context,
		contextualize,revise,revision,sum,sum-up,take-away,takeaway`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`explain,explaining,explains,clarify,simplify,formulate,solve,determine,reason,reasoning,enlighten,decode,descrypt,unscramble,portray,comment,assert,disclose,depict,identify,find,pinpoint,
		expound,exemplify,represent,annotate,annotating,delineate,define,designate,illustrate,reveal,tell,elucidate,paraphrase,unravel,untangle,describe,mean,
		symbolize,exhibit,embody,epitomize,utter,communicate,declare,divulge,impart,notify,specify,expose,proclaim`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`opine,believe,posit,presume,feel,imagine,envisage,envision,visualize,perceive,anticipate,foresee,realize,suppose,pretend,hypothesis,
		hypothesize,speculate,estimate,presuppose,judge,guess,divine,stab,surmise,	rekon,decipher,deduce,infer,postulate,venture,conjecture,predict,
		guesstimate,ascertain`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`understand,glean,know,get,comprehend,comprehension,learn,fathom,deem,grasp,master,point,recognize,distinguish,information,inform`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`prior,previous,previously,back`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`compare,correlate,contrast,diverge,vary,equal,than,less,fewer,reduced,greater,increrase,increased,higher,added,larger,more,improve,improved,enhance,enhanced,
		raise,raised,better,worse,changed,modify,modified,next,last,later,before,previous,previously,since,former,afterward,afterwards,subsequently,since,after,shift,
		differ,differed,difference`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`reflect,contemplate,think,consider,interpret,decide,decision,characterize,argue,claim,advocate,suggest,remember,remind,recollect,invoke,
		theorize,suspect,scrutinize,conclude,conclusion,concede,ponder`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		
		}

	function Test500s()
	{
		let i,j,k,o,v,num;
		trace(Object.keys(keySyns).length)

		for (i=0;i<rawData.length;++i) {															// For each line
			o=rawData[i];																			// Point at it
			if (o.speaker != "Teacher") continue;
			v=nlp.Tokenize(o.text);
			if (v.length < 4) 			continue;													// Skip if short
			if (o.intent < 100)			continue;
			num=0;
			for (k=0;k<v.length;++k) if (keySyns[v[k]]) num++;
			o.keyVal=num/Object.keys(keySyns).length;
			trace(Math.floor(o.intent/100)*100+"\t"+o.keyVal);
			
		}
	}






</script>
</body>
</html>



