<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<link REL="SHORTCUT ICON" HREF="img/favicon.ico">
		<title>dataParser</title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
		<script src="lib/papaparse.min.js"></script>
		<script src="nlp.js"></script>
	</head>
	<style>
		body { 	font-family:Segoe UI,Verdana,Geneva,sans-serif;font-size:16px; margin:20px; }
		.lz-is 		{	border-radius:16px; padding:0 8px; height: 24px; border:1px solid #999; font-size: 13px; text-align:center; }
		.lz-bs 		{	display:inline-block; border-radius:16px; padding:0 16px; border:1px solid #999; font-size: 13px; 
						cursor:pointer; z-index:2; padding-bottom:1px; color:#000; background-color: #eee; font-weight:600; }
		.lz-bsg		{	cursor: pointer; color:#fff; text-align: center; border-radius: 16px; display: inline-block; user-select: none;
						font-size: 13px; background-color: #999; padding: 2px 8px 2px 8px; }
		.lz-confirm {	position: absolute;  width: 300px; padding: 16px; left: calc(50% - 150px); top: calc(50% - 50px); user-select: none;	
						border-radius: 8px; background-color: #fff; border: 1px solid #999; box-shadow: 4px 2px 12px 2px #aaa; }
	</style>
	<body>
		<input type="file" id="lz-tempFile" accept=".csv,.CSV" style="display:none">
		<input type="file" id="lz-trainFile" accept=".csv,.CSV,.yml" style="display:none">
		<input type="file" id="lz-testFile" accept=".csv,.CSV,.yml" style="display:none">
		<input type="file" id="lz-augmentFile" accept=".csv,.CSV,.yml" style="display:none">

		<div style="width:66%;margin:0 auto;text-align:center">
			<img src="img/logo.png" style="width:25%">
			<hr>
			AI: &nbsp;<select class="lz-is" id="lz-aiType">
				<option>Wit</option><option>Dialog</option>
				</select>&nbsp &nbsp; 
			Activity: &nbsp;<select class="lz-is" id="lz-dataset">
					<option>Test</option><option>Activity3</option><option>Fiction</option><option>Space</option>
					</select>&nbsp &nbsp; 
				<div class="lz-bs" id="lz-testData">Test data</div>
				&nbsp; &nbsp; &nbsp;<div class="lz-bs" id="lz-trainData">Train data</div>
				&nbsp; &nbsp; &nbsp;<div class="lz-bs" id="lz-deleteData">Delete data</div>
				&nbsp; &nbsp; &nbsp;<div class="lz-bs" id="lz-augmentData">Augment data</div>
			</p>
			<hr><br>
			Type test remark here: <input type="input" class="lz-is" style="width:50%" id="lz-utter"/> &nbsp; <span id="lz-result"></span>
			<br><br><hr><br>
			<p id="outp" style="text-align:left"></p>
		</div>
	
<script>

/////////////////////////////////////////////////////////////////////////////////////////////////
// APP 
/////////////////////////////////////////////////////////////////////////////////////////////////

	let rawData=[], intents=[], session=[], keyWords=[], vocab=[]; uvocab=[];
	let nlp=new NLP();																				// Alloc NLP class
	let ws=null;																					// Socket server				
	let aiType="wit";																				// AI type

	let modelName="Test";																		// AI Model to use
	let witToken={};
	witToken.Space=  "ZS2-X-HDBR57B-X-O6JWK37PVPODW-X-RXXMGA4FN".replace(/-X-/g,"");				// Space service access token
	witToken.Fiction="AH7-X-LA4QMUA-X-K6C4JCH7V7SH6-X-ULUGH6WTE".replace(/-X-/g,"");				// Fiction service access token
	witToken.Activity3="CK5DKYH-X-DQJJ23R-X-ADW6R5T66BAD-X-ZEE6KO".replace(/-X-/g,"");				// Acitivity 3/4
	witToken.Test="GF34C42CT4-X-6PWFV5XKG-X-OO7URKYE-X-KT4EH".replace(/-X-/g,"");					// Test 

	$(document).ready(function() {								           							// ON PAGE LOADED
		InitSocketServer();
		$("#lz-testData").on("click",()=>  	  { $("#lz-testFile").trigger("click"); } );			// ON TEST TRAINING DATA
		$("#lz-deleteData").on("click", ()=>  { DeleteTrainingData(); } );							// ON DELETE TRAINING DATA
		$("#lz-trainData").on("click", ()=>   { if (window.location.host == "localhost") $("#lz-trainFile").trigger("click"); }); 	// ON TRAIN DATA		
		$("#lz-augmentData").on("click", ()=> { $("#lz-augmentFile").trigger("click")});			// ON AUGMENT TRAINING DATA
		$("#lz-dataset").on("change", ()=>    { modelName=$("#lz-dataset").val(); });				// ON DATASET CHANGE
		$("#lz-aiType").on("change", ()=>     { aiType=$("#lz-aiType").val().toLowerCase(); });		// ON AI CHANGE
				
		$("#lz-tempFile").on("change",(e)=>{														// ON TEMP FILE LOAD
			ImportCSV(e);																			// Read file
			$("#lz-tempFile").val("");																// Clear value		
			});
		$("#lz-trainFile").on("change",(e)=>{														// ON TRAIN FILE LOAD
			TrainData(e);																			// Read file
			$("#lz-trainFile").val("");																// Clear value		
			});
		$("#lz-augmentFile").on("change",(e)=>{														// ON AUGMENT FILE LOAD
			AugmentData(e);																			// Read file
			$("#lz-augmentFile").val("");																// Clear value		
			});
		$("#lz-testFile").on("change",(e)=>{														// ON TEST FILE LOAD
			TestData(e);																			// Read file
			$("#lz-testFile").val("");																// Clear value		
			});

		$("#lz-utter").on("change",(e)=>{															// ON TEST REMARK
			InferIntents([{text:$("#lz-utter").val()}],(r)=>{
				trace(r)
				$("#lz-result").html(`<b>${r.intent}</b> at ${Math.round(r.confidence*100)}%`);
				});
			});

		$(window).on("keydown",function(e) {														// HANDLE KEYPRESS
			if ((e.which == 81) && e.ctrlKey)	{										// Test key (CTL-Q)
				}
			});
	});

	async function TrainData(e)																	// TRAIN DATA
	{	
		let file=e.target.files[0];																	// Point at file
		if (!file) 	return;																			// Quit if bad
		let holds=[];
		let reader=new FileReader();																// Init reader
		reader.readAsText(file);																	// Read file
		reader.onload=(e)=>{ 																		// When loaded
			let uniqueIntents=[];																	// Hold unique intents used
			let i,d=Papa.parse(e.target.result.replace(/[!|?]/g,"."),{ header:true, skipEmptyLines:true }).data;	// Parse CSV using papa lib
			SaveResponseFile(d);																	// Save student responses to new CSV file			
			for (i=0;i<d.length;++i) {																// For each remark
				if (d[i].intent) uniqueIntents.push(d[i].intent);									// Get intent
				if (d[i].note == "hold") { 															// Remove/save holds
					holds.push(d[i]);																// Save hold
					d.splice(i,1); 																	// Remove from training
					continue; 																		// Contineu
					}								
				if (!d[i].remark) 		 { d.splice(i,1); continue; }								// No remark
				if (!d[i].intent) 		 { d.splice(i,1); continue; }								// No intent
				}
			uniqueIntents=[... new Set(uniqueIntents)];												// Make unique

			if (aiType == "wit") {																	// WIT.AI
				ConfirmBox("Are your sure?","Old data must be deleted first.",()=>{					// Confirm
					TrainWit(d,uniqueIntents);														// Add intents and utterances	
					});
				}
			else if (aiType == "dialog") {															// DIALOGFFLOW
				TrainDialog(d,uniqueIntents);														// Load and make training data	
				}
			if (holds.length) {																		// If any holds
				let fields=["intent","remark","note"];												// Field names
				let str=Papa.unparse(holds,{ header:true, skipEmptyLines:true, columns:fields });	// Make CSV using lib
				SaveTextAsFile("holds.csv",str);													// Write file
				}
			};
	}

	async function AugmentData(e)																// AuGMENT DATA
	{	
		let file=e.target.files[0];																	// Point at file
		if (!file) 	return;																			// Quit if bad
		let reader=new FileReader();																// Init reader
		reader.readAsText(file);																	// Read file
		reader.onload=(e)=>{ 																		// When loaded
			let i,d=Papa.parse(e.target.result.replace(/[!|?]/g,"."),{ header:true, skipEmptyLines:true }).data;	// Parse CSV using papa lib
			SaveResponseFile(d);																	// Save student responses to new CSV file			
			for (i=0;i<d.length;++i) {																// For each remark
				if (!d[i].remark) 		 { d.splice(i,1); continue; }								// No remark
				if (!d[i].intent) 		 { d.splice(i,1); continue; }								// No intent
				}
			let fields=["intent","remark","note"];													// Field names
			let str=Papa.unparse(d,{ header:true, skipEmptyLines:true, columns:fields });			// Make CSV using lib
			SaveTextAsFile("augmented.csv",str);													// Write file
			};
	}


	function DeleteTrainingData()															// DELETE TRAINING DATA
	{
		if (window.location.host != "localhost") 	return;											// Only local can delete
			ConfirmBox("Are your sure?","",()=>{													// Confirm
				if (aiType == "wit") {																// WIT.AI
					WitGetUtterances((d)=>{															// Get utterance list		
						WitDeleteUtternances(d,(r)=>{ trace(r);	});									// Delete existing utterances									
						});
					WitGetIntents((d)=>{															// Get intents list		
						WitDeleteIntents(d,(r)=>{ trace(r);	},(r)=>{ trace(r);	});					// Delete existing intents
						});
					}
				});
	}

	async function TestData(e)																	// TEST DATA
	{	
		let i,k,o,v,id,str,s="";
		let file=e.target.files[0];																	// Point at file
		if (!file) 	return;																			// Quit if bad
	
		let reader=new FileReader();																// Init reader
		reader.readAsText(file);																	// Read file
		reader.onload=(e)=>{ 																		// When loaded
			LoadingIcon(true);																		// Show loading icon
				let count=0,notFound=0;																// Counts
				let d=[],orig=[];
				let v=Papa.parse(e.target.result, { header:true, skipEmptyLines:true }).data;		// Parse CSV using papa lib
				for (i=0;i<v.length;++i) if (v[i].note == "hold")	d.push(v[i]),orig.push(v[i]);	// Only holds
				let tot=d.length;																	// Total
				InferIntents(d, (res)=>{ 															// On each inference
					i=(tot-d.length-1);																// Current index
					if (res.intent == "efault Fallback Intent") res.intent=res.confidence=0;		// Not found
					orig[i].intent=orig[i].intent.toLowerCase();									// Force LC
					orig[i].confidence=res.confidence;												// Save confidence
					orig[i].infer=res.intent;														// Save inferred intent
					
					orig[i].match=(res.intent == orig[i].intent) ? 1 : 0;							// Do they match?
					if (res.confidence < .4)	 orig[i].match=-1;									// Not properly inferred
					count+=orig[i].match;															// Add to count
					$("#lz-loadingIconText").html("<b>"+Math.floor(i/tot*100)+"%</b>");				// Show progress
					if (!d.length) {																// If last one
						Sound("ding");																// Ding				
						LoadingIcon(false);															// Hide loading icon
						let fields=["intent","remark","note","confidence","infer","match"];			// Field names
						str=Papa.unparse(orig,{ header:true, skipEmptyLines:true, columns:fields });// Make CSV using lib
						SaveTextAsFile("test.csv",str);												// Write file
						let results=[];
						for (i=0;i<orig.length;++i) {												// For each utterance
							if (!results[orig[i].intent]) {											// First one
								results[orig[i].intent]={};											// Add obj
								results[orig[i].intent].tot=0;										// Init
								results[orig[i].intent].match=0;	
								}
							if (orig[i].match == 1) results[orig[i].intent].match++;				// If a match
							if (orig[i].match == -1) notFound++;									// Add to bad count
							
							
							results[orig[i].intent].tot++;											// Add to count
							}
						for (o in results) 
							s+=o.toUpperCase()+" "+results[o].match+"/"+results[o].tot+" has "+Math.round(results[o].match/results[o].tot*100)+"% accuracy<br>";	// Intent accuracy
						s+="<br>"+Math.round(count/tot*100)+"% total accuracy";						// Total accuracy
						s+="<br>"+notFound+" Not categorized";										// Uncategorized
						$("#outp").html(s.replace(/\t|\n|\r/g,""));									// Show stats
					}
					});
				}

	}

	async function InferIntents(msgs, callback)													// GET RESPONSE FROM AI
	{
		try {
		let m=msgs.shift();																			// Remove from list
		let inference={ text:m.text, labeled:m.intent, intent:0, confidence:0 };					// Null inference
		if (aiType == "rasa") {																		// If RASA
			const response=await fetch("https://lizasim.com:5005/model/parse", {					// Fetch data
				method:"POST",																		// POST
				body: JSON.stringify({text:m.remark})													// Payload	
				});
			let res=await response.json();															// Get response 
			inference.intent=res.intent.name.substr(1);												// Intent																		
			inference.confidence=res.intent.confidence;												// Confidence
			inference.labeled=m.intent;																// Labeled intent
			callback(inference);																	// Return inference object
			if (msgs.length) InferIntents(msgs, callback)											// Recurse, if not last
			}
		else if (aiType == "dialog") {																// If DIALOGFLOW
			let p=new Promise((resolve, reject) => {
				trace(m)
				setTimeout(()=>{ws.send("Test|DIALOGFLOW|ADMIN|INFER|activity3-viod|"+m.remark.substring(0,255))},500);
				ws.onmessage=(e)=>{ 																// If a ws message
					if (!e.data)			 return;												// Quit if no data
					let v=event.data.split("|");													// Get params
					if (v[1] != "DIALOGFLOW") return;												// Not a dialogflow inference
					resolve(v) };																	// Resolve promise
				}).then(res =>{ 																	// On resolution
					inference.intent=res[2].substr(1);												// Intent																		
					inference.confidence=res[3];													// Confidence
					callback(inference); 															// Return inference
					if (msgs.length) InferIntents(msgs, callback)									// Recurse, if not last
					});
			}
		else if (aiType == "wit") {																	// If WIT
			let url="https://api.wit.ai/message?v=20210922&n=3&q="+m.text.substring(0,255);		// URL			
				const response=await fetch(url, { headers:{ Authorization:'Bearer '+witToken[modelName], 'Content-Type':'application/json'} });	// Send remark to wit
			let res=await response.json();															// Get response
			if (res.intents.length) {																// If an intent found
				inference.intent=res.intents[0].name.substring(1);									// Get intent																		
				inference.confidence=res.intents[0].confidence;										// Confidence
				}	
			trace(res)
			callback(inference);																	// Return response
			if (msgs.length) setTimeout(()=>{ InferIntents(msgs, callback);},200);					// Recurse, if not last and add delay
			}
		} catch(e) {trace(e)}
	} 

	function InitSocketServer()																	// INIT SOCKET SERVER
	{
		if (window.location.host == "localhost") ws=new WebSocket('ws://'+window.location.host+':8080');	// Open insecure websocket											
		else									 ws=new WebSocket('wss://'+window.location.host+':8082');	// Secure											
		ws.onclose=()=>   { console.log('disconnected'); ws=null; Sound("delete") };				// ON CLOSE
		ws.onerror=(e)=>  { console.log('error',e);	};												// ON ERROR
		ws.onopen=()=> 	  { console.log('connected'); };											// ON OPEN
	}
	
/////////////////////////////////////////////////////////////////////////////////////////////////
// OUTPUT 
/////////////////////////////////////////////////////////////////////////////////////////////////

	function FindPreviousResponse(ind)															// GET PREVIOUS STUDENT RESPONSE
	{
		while (--ind >= 0) {																		// Search backwards
			if (rawData[ind].speaker != "Teacher") 													// If not a teacher
				return rawData[ind].text;															// Return previous response
			}
		return "";																					// No previous response
	}

	function ImportCSV(e) {																		// IMPORT SESSION FROM CSV
		let i,d="";
		let file=e.target.files[0];																	// Point at file
		if (!file) 	return;																			// Quit if bad
		let reader=new FileReader();																// Init reader
		reader.readAsText(file);																	// Read file
		reader.onload=(e)=>{ 																		// When loaded
			let csv=Papa.parse(e.target.result, { header:false, skipEmptyLines:true }).data;		// Parse CSV using papa lib
			for (i=0;i<csv.length;++i) {															// For each line
				if (csv[i][8] == "Teacher")	{														// Only remarks
					if (csv[i][11] == "1") 		s=csv[i][11];										// Original correction
					else if (csv[i][11] == "2") s=csv[i][13];										// Double correction
					else						s=csv[i][10];										// No correction, use original
					if (s.length < 4)			continue;											// Skip if too short
					s=nlp.CleanRemark(s);															// Make line	
					d+="    - "+s+"\n";																// Add
					}
				}
			trace(d)
			Sound("ding");																			// Ding
			};
	}

	function SaveResponseFile(f)																// EXTRACT AND SAVE STUDENT RESPONSES
	{
		let i,v=[];
		let fields=["intent","student","response","valued","language","knowledge","thinking","action","understanding","responseType"];			// Field names
		for (i=0;i<f.length;++i) 																	// For each responses
			if (f[i].response &&  f[i].intent) v.push(f[i]);										// If there, add it
		let str=Papa.unparse(v,{ header:true, skipEmptyLines:true, columns:fields });				// Make CSV using lib
		SaveTextAsFile("responses.csv",str);														// Write file
	}

///////////////////////////////////////////////////////////////////////////////////////////////
// WIT
/////////////////////////////////////////////////////////////////////////////////////////////////

	async function TrainWit(d, newIntents)														// TRAIN WIT
	{	
		LoadingIcon(true);																			// Show loading icon
		let tot=d.length;																			// Total to train
		WitGetIntents((ins)=>{																		// Get intents list		
			if (ins.length) {
				WitDeleteIntents(ins,(r)=>{},()=>{													// Delete intents recursively
				WitAddIntents(newIntents,()=>{},()=>{												// Add intents recursively
					WitTrain(d, (r1,r2)=>{															// Start sending via recursion		
						trace(r1,r2);																// Log	
						$("#lz-loadingIconText").html("<b>"+(100-Math.floor(d.length*100/tot))+"%</b>"); // Show progress
						if (!d.length) {															// If last one
							Sound("ding");															// Ding				
							LoadingIcon(false);														// Hide loading icon
							}
						});											
					});											
				});
			}
			else{
				WitAddIntents(newIntents,()=>{},()=>{												// Add intents recursively
					WitTrain(d, (r1,r2)=>{															// Start sending via recursion		
						trace(r1,r2);																// Log	
						$("#lz-loadingIconText").html("<b>"+(100-Math.floor(d.length*100/tot))+"%</b>"); // Show progress
						if (!d.length) {															// If last one
							Sound("ding");															// Ding				
							LoadingIcon(false);														// Hide loading icon
							}
						});											
					});											
				}
			});

	}

	function WitGetUtterances(callback)															// GET ARRAY OF UTTERANCES
	{
		const url="https://api.wit.ai/utterances?v=20210922&limit=10000";							// URL 
		const response=fetch(url, { 																// Send command to wit
			  headers: { Authorization:'Bearer '+witToken[modelName], 'Content-Type':'application/json'} 
			  })	
			.then(res => res.json()).then(res =>{callback(res); });									// Send data back
	}

	async function WitGetIntents(callback)														// GET ARRAY OF INTENTS
	{
		const url="https://api.wit.ai/intents?v=20210922&limit=10000";								// URL 
		const response=fetch(url, { 																// Send command to wit
			  headers: { Authorization:'Bearer '+witToken[modelName], 'Content-Type':'application/json'} 
			  })	
			.then(res => res.json()).then(res =>{callback(res); });									// Send data back
	}

	function WitDeleteUtternances(utterances, callback)											// DELETE UTTERANCES FROM SERVER
	{
		const url="https://api.wit.ai/utterances?v=20210922";										// URL 
		const response=fetch(url, { 																// Send command to wit
			  method:"DELETE",
			  headers: { Authorization:'Bearer '+witToken[modelName], 'Content-Type':'application/json'}, 
			  body: JSON.stringify(utterances)
			  })	
		  .then(res => res.json()).then(res =>{callback(res); });									// Send data back
	}

	async function WitDeleteIntents(msgs, callback, done)										// DELETE INTENT FROM SERVER
	{
		let m=msgs.shift();																			// Remove from list and save first
		if (!m)	return;																				// Nothing to do
		trace("Deleted: "+m.name);																	// Log
		const url="https://api.wit.ai/intents/"+m.name+"?v=20210922";								// URL 
		const response=await fetch(url, { 															// Send remark to wit
			  method:"DELETE",
			  headers: { Authorization:'Bearer '+witToken[modelName], 'Content-Type':'application/json'}, 
			  });	
		let res=await response.json();																// Get response
		if (msgs.length) setTimeout(()=>{ WitDeleteIntents(msgs, callback, done) },500);			// Recurse, if not last
		else done(123);
	}

	async function WitTrain(msgs, callback, done)												// SEND REMARK TO WIT TO TRAIN
	{
		for (let i=480;i<600;i+=10) 	SaveTextAsFile("r"+i+".json",`{ "name": "r${i}", }`);	
		let res=null,inference={ text:"", intent:0, confidence:0 };									// Null inference
		let m=msgs.shift();																			// Remove from list and save first
		if (!isNaN(m.intent)) m.intent="r"+m.intent;												// Numbers need to be prefixed with a letter
		const url="https://api.wit.ai/utterances?v=20210922";										// URL 
		let body=[{ text:m.remark.substring(0,255), intent:m.intent.toLowerCase(), entities:[], traits: [] }];	// Make body
		const response=await fetch(url, { 															// Send remark to wit
			  method:"POST",
			  headers: { Authorization:'Bearer '+witToken[modelName], 'Content-Type':'application/json'}, 
			  body: JSON.stringify(body)
			  });	
		res=await response.json();																	// Get response
		callback(m,res);																			// Return responss
		if (msgs.length) setTimeout(()=>{ WitTrain(msgs, callback, done) },500);						// Recurse, if not last
	}

	async function WitAddIntents(msgs, callback, done)												// SEND REMARK TO WIT TO TRAIN
	{
		let m=msgs.shift();																			// Remove from list and save first
		if (!m)	return;																				// Nothing to do
		if (!isNaN(m)) m="r"+m;																		// Numbers need to be prefixed with a letter
		const url="https://api.wit.ai/intents?v=20210922";											// URL 
		let body={ name:m.toLowerCase()};															// Make body
		const response=await fetch(url, { 															// Send remark to wit
			  method:"POST",
			  headers: { Authorization:'Bearer '+witToken[modelName], 'Content-Type':'application/json'}, 
			  body: JSON.stringify(body)
			  });	
		let res=await response.json();																// Get response
		trace(res)
		if (msgs.length) setTimeout(()=>{ WitAddIntents(msgs, callback, done) },500);				// Recurse, if not last
		else done(123);

	}


///////////////////////////////////////////////////////////////////////////////////////////////
// DIALOGFLOW
/////////////////////////////////////////////////////////////////////////////////////////////////
	
	function TrainDialog(d, uniqueIntents)													// MAKE DIALOGFLOW INTENT FILE
	{
		let intent,str,i,s;
		for (i=0;i<uniqueIntents.length;i++) 	SaveTextAsFile("r"+uniqueIntents[i]+".json",`{ "name":"r${uniqueIntents[i]}", "auto":true }`);	
		let v=groupBy(d,"intent");																// Group by intent																
		for (intent in v) {																		// For each intent
			trace(intent)
			str="[\n";
			for (i=0;i<v[intent].length;++i) {													// For each one wanted
				s=v[intent][i].remark.replace(/"/g,"");											// No quotes
				s=s.replace(/'/g,"\\u0027");													// Escape apos
				str+=`{ "data": [{ "text": "${s}", "userDefined": false }], "isTemplate": false, "count": 1, "lang": "en", "updated": 0 },\n`;
				}
			str=str.slice(0,-2)+"\n]";
			SaveTextAsFile("r"+intent+"_usersays_en.json",str);									// Write intent file
			}

		function groupBy(arr, property) {														// GROUP
			return arr.reduce((acc, cur) => {
				acc[cur[property]] = [...acc[cur[property]] || [], cur];
				return acc;
				}, {});
			}
	
	}	

///////////////////////////////////////////////////////////////////////////////////////////////
// OPENAI
/////////////////////////////////////////////////////////////////////////////////////////////////

/*

{
  "queryParams": {
    "sentimentAnalysisRequestConfig": {
      "analyzeQueryTextSentiment": true
    }
  },
  "queryInput": {
    "text": {
      "text": "please reserve an amazing meeting room for six people",
      "languageCode": "en-US"
    }
  }
}
	function OAIGet(msg)																	// GET RESPONSE FROM AI
	{
		let body={
		"prompt": "The following is a list of companies and the categories they fall into\n\nFacebook: Social media, Technology\nLinkedIn: Social media, Technology, Enterprise, Careers\nUber: Transportation, Technology, Marketplace\nUnilever: Conglomerate, Consumer Goods\nMcdonalds: Food, Fast Food, Logistics, Restaurants\nFedEx:",
		"temperature": 0,
		"max_tokens": 6,
		"top_p": 1.0,
		"frequency_penalty": 0.0,
		"presence_penalty": 0.0,
		"stop": ["\n"]
		}

		const url="https://api.openai.com/v1/engines/davinci/completions"
		let token="sk-u4nGW65-X-gajLxEDQlh9OTT3BlbkF-X-JHp7xp1JaQ5HJT7Ca3pqs".replace(/-X-/g,"");	// Get token
		fetch(url,{ method:"POST",
			  headers: { Authorization:'Bearer '+token, 'Content-Type':'application/json'}, 
			  body: JSON.stringify(body)
			  })	
	  	.then(res => res.json()).then(res =>{ trace(res); })
	}
*/


/////////////////////////////////////////////////////////////////////////////////////////////////
// HELPERS 
/////////////////////////////////////////////////////////////////////////////////////////////////

	function trace(msg, p1, p2, p3, p4)																// CONSOLE 
	{
		if (p4 != undefined)
			console.log(msg,p1,p2,p3,p4);
		else if (p3 != undefined)
			console.log(msg,p1,p2,p3);
		else if (p2 != undefined)
			console.log(msg,p1,p2);
		else if (p1 != undefined)
			console.log(msg,p1);
		else
			console.log(msg);
	}

	function Sound(sound, mute)																		// PLAY SOUND
	{
		var snd=new Audio();																			// Init audio object
		if (sound.match(/\.mp3/i))		snd=new Audio(sound)											// If an MP3 file
		else							snd=new Audio("img/"+sound+".mp3");								// Use built in mp3
		if (!mute)	{																					// If not initing or muting	
			snd.volume=100/100;																			// Set volume
			snd.play();																					// Play it
			}
		}

	function SaveTextAsFile(file, contents)															// SAVE TEXT TO LOCAL FILE
	{
		if (file.charAt(0) == "*") {																	// If asking
			GetTextBox("Type file name","", file.substr(1), (s)=>{ SaveTextAsFile(s, contents); });		// Ask for name
			return;																						// Quit
			}
		var textFileAsBlob=new Blob([contents], {type:'text/plain'});
		var downloadLink=document.createElement("a");
		downloadLink.download=file;
		downloadLink.innerHTML="Download File";
		downloadLink.href=window.URL.createObjectURL(textFileAsBlob);
	    downloadLink.onclick=()=>{ downloadLink.remove(); };
		downloadLink.style.display="none";
		downloadLink.id="tdll";
		document.body.appendChild(downloadLink);
		downloadLink.click();
	}

	function GetTextBox(title, content, def, callback)											// GET TEXT LINE BOX
	{
		$("#confirmBoxDiv").remove();																	// Remove 
		$("body").append("<div class='lz-confirm' id='confirmBoxDiv'></div>");							// Add box								
		var str="<img src='img/smlogo.png' width='64' style='vertical-align:-8px'/>&nbsp;&nbsp;";								
		str+="<span style='font-size:14px; color:#666'><b>"+title+"</b></span><br><br>";
		str+="<p>"+content+"<p>";
		str+="<p><input class='lz-is' style='width:75%' type='text' id='gtBoxTt' value='"+def+"'></p>";
		str+="<div id='dialogOK' class='lz-bs'>OK</div>";
		str+="<div id='dialogCancel' class='lz-bs' style='margin-left:8px;background-color:#999'>Cancel</div></div>";
		$("#confirmBoxDiv").html(str);																	// Add to div
		$("#gtBoxTt").focus();																			// Focus on button
		$("#gtBoxTt").on("change", function() {	callback($("#gtBoxTt").val()); $("#confirmBoxDiv").remove(); });	// ONE ENTER
		$("#dialogOK").on("click", function() {	callback($("#gtBoxTt").val()); $("#confirmBoxDiv").remove(); });	// ON OK 
		$("#dialogCancel").on("click", function() {	$("#confirmBoxDiv").remove(); });								// ON CANCEL
		}

	function ConfirmBox(title, content, callback, callback2)										// CONFIRMATION BOX
	{
		Sound("ding");																					// Ding sound
		$("#confirmBoxDiv").remove();																	// Remove 
		$("body").append("<div class='lz-confirm' id='confirmBoxDiv'></div>");							// Add dialog												
		var str="<img src='img/smlogo.png' width='64'>";												// Logo							
		str+="<span style='font-size:16px;float:right;color:#b9220a;margin-top:6px'><b>"+title+"</b></span><br>"; // Title
		str+="<p>"+content+"<p>";
		str+="<div style='float:right'><div id='confirmOK' class='lz-bs'>OK</div>";
		str+="<div id='confirmCancel' class='lz-bs' style='margin-left:8px;background-color:#999'>Cancel</div></div>";
		$("#confirmBoxDiv").html(str);	
	
		$("#confirmOK").on("click", function() {														// ON OK BUT
				$("#confirmBoxDiv").remove();															// Remove 
				if (callback)	callback();																// If callback defined, run it
				});

		$("#confirmCancel").on("click", function() {													// ON CANCEL BUT
				$("#confirmBoxDiv").remove();															// Remove 
				if (callback2)	callback2();															// If callback defined, run it
				Sound("delete");																		// Delete sound
				});
	}

	function TimecodeToSeconds(timecode) 														// CONVERT TIMECODE TO MILLISECONDS
	{
		if (!timecode)	return 0;
		let t=0;
		let v=timecode.match(/(\d*):(\d*):(\d*)\.*(\d*)/);											// Parse
//		t+=v[1]*60*60*1000;																			// Get hours
		t+=v[2]*60*1000;																			// Get mins
		t+=v[3]*1000;																				// Get secs
		if (v[4]) t+=v[4]/1000;																		// Ms
		return t;																					// Return time in ms
	}

	function LoadingIcon(mode)																	// SHOW/HIDE LOADING ICON		
	{
		if (!mode) {																				// If hiding
			$("#lz-loadingIcon").remove();															// Remove it
			return;																					// Quit
			}
		let str="<div id='lz-loadingIcon' style='position:absolute;top:calc(50% - 64px);left:calc(50% - 64px);z-index:5000;text-align:center'>";
		str+="<img src='img/loading.gif' width='128'>";												// Img
		str+="<div id='lz-loadingIconText' style='margin-top:-78px;color:#999'></div></div>";		// Progress
		$("body").append(str);																		// Add icon to container
	}

/////////////////////////////////////////////////////////////////////////////////////////////////
// KEYS / VOCAB
/////////////////////////////////////////////////////////////////////////////////////////////////
	let keySyns=[];
	MakeActionKeys()

	function MakeActionKeys()
	{
		let i,v;
		v=(`strategy,strategies,policy,policies,procedure,procedures,approach,approaches,approaching,blueprint,program,stratagem,stratagems,
		plan,plans,planning,guideline,guidance,scheme,schema,organize,organization,tenet,path,pathway,avenue,agenda,agendas,agendum,channel,channels,modus,operandi,maneuver,
		process,prototype,archetype,model,theory,theories,structure,structures,arrange,arrangement,arranging,classify,classification,clue,incorporate,integrate,
		sort,proposal,propose,codify,codification,layout,design,designs,coordinate,create,creating,created,establish,standardize,figured,skill,skills,
		rule,rules,construct,constructs,constructed,constructing,invent,technique,progression,unfolding,architecture,catalog,catalogue,alphabetize,pattern,
		method,manner,mechanism,rubric,routine,scenario,outline,synopsis,summary,summarize,rundown,run-down,review,recap,recapitulation,
		analysis,keyword,keywords,key_word,sequence.chronological,timeline,concept,concepts,conceptualize,context,
		contextualize,revise,revision,sum,sum-up,take-away,takeaway`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`explain,explaining,explains,clarify,simplify,formulate,solve,determine,reason,reasoning,enlighten,decode,descrypt,unscramble,portray,comment,assert,disclose,depict,identify,find,pinpoint,
		expound,exemplify,represent,annotate,annotating,delineate,define,designate,illustrate,reveal,tell,elucidate,paraphrase,unravel,untangle,describe,mean,
		symbolize,exhibit,embody,epitomize,utter,communicate,declare,divulge,impart,notify,specify,expose,proclaim`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`opine,believe,posit,presume,feel,imagine,envisage,envision,visualize,perceive,anticipate,foresee,realize,suppose,pretend,hypothesis,
		hypothesize,speculate,estimate,presuppose,judge,guess,divine,stab,surmise,	rekon,decipher,deduce,infer,postulate,venture,conjecture,predict,
		guesstimate,ascertain`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`understand,glean,know,get,comprehend,comprehension,learn,fathom,deem,grasp,master,point,recognize,distinguish,information,inform`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`prior,previous,previously,back`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`compare,correlate,contrast,diverge,vary,equal,than,less,fewer,reduced,greater,increrase,increased,higher,added,larger,more,improve,improved,enhance,enhanced,
		raise,raised,better,worse,changed,modify,modified,next,last,later,before,previous,previously,since,former,afterward,afterwards,subsequently,since,after,shift,
		differ,differed,difference`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`reflect,contemplate,think,consider,interpret,decide,decision,characterize,argue,claim,advocate,suggest,remember,remind,recollect,invoke,
		theorize,suspect,scrutinize,conclude,conclusion,concede,ponder`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		}

</script>
</body>
</html>



