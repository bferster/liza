<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<link REL="SHORTCUT ICON" HREF="img/favicon.ico">
		<title>dataParser</title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
		<script src="lib/papaparse.min.js"></script>
		<script src="nlp.js"></script>
	</head>
	<style>
		body { 	font-family:Segoe UI,Verdana,Geneva,sans-serif;font-size:16px; margin:20px; }
		.lz-is 		{	border-radius:16px; padding:0 8px; height: 24px; border:1px solid #999; font-size: 13px; text-align:center; }
		.lz-bs 		{	display:inline-block; border-radius:16px; padding:0 16px; border:1px solid #999; font-size: 13px; 
						cursor:pointer; z-index:2; padding-bottom:1px; color:#000; background-color: #eee; font-weight:600; }
		.lz-bsg		{	cursor: pointer; color:#fff; text-align: center; border-radius: 16px; display: inline-block; user-select: none;
						font-size: 13px; background-color: #999; padding: 2px 8px 2px 8px; }
		.lz-confirm {	position: absolute;  width: 300px; padding: 16px; left: calc(50% - 150px); top: calc(50% - 50px); user-select: none;	
						border-radius: 8px; background-color: #fff; border: 1px solid #999; box-shadow: 4px 2px 12px 2px #aaa; }
	</style>
	<body>
		<input type="file" id="lz-tempFile" accept=".csv,.CSV" style="display:none">
		<!--div class="lz-bs" id="lz-importData" style="margin:12px">Load session</div-->
		<input type="file" id="lz-trainFile" accept=".csv,.CSV,.yml" style="display:none">
		<input type="file" id="lz-testFile" accept=".csv,.CSV,.yml" style="display:none">

		<div style="width:66%;margin:0 auto;text-align:center">
			<img src="img/logo.png" style="width:25%">
			<hr>
			AI: &nbsp;<select class="lz-is" id="lz-aiType">
				<option>Wit</option><option>Dialog</option>
				</select>&nbsp &nbsp; 
			Activity: &nbsp;<select class="lz-is" id="lz-dataset">
					<option>Activity3</option><option>Fiction</option><option>Space</option>
					</select>&nbsp &nbsp; 
				<!--
				&nbsp &nbsp; Series: <select class="lz-is" id="lz-series">
				<option>Hundreds</option><option>Tens</option><option>Decimals</option><option>
			</select>
			&nbsp &nbsp; Max per intent: <input type="input" class="lz-is" style="width:40px" value="500" id="lz-num"/>
			&nbsp &nbsp; Test % <input type="input" class="lz-is" style="width:40px" value="0" id="lz-holdOut"/>
			<hr><p-->
				<div class="lz-bs" id="lz-testData">Test data</div>
				&nbsp; &nbsp; &nbsp;<div class="lz-bs" id="lz-trainData">Train data</div>
				&nbsp; &nbsp; &nbsp;<div class="lz-bs" id="lz-deleteData">Delete data</div>
			</p>
			<hr><br>
			Type test remark here: <input type="input" class="lz-is" style="width:50%" id="lz-utter"/> &nbsp; <span id="lz-result"></span>
			<br><br><hr><br>
			<p id="outp" style="text-align:left"></p>
		</div>
	
<script>

/////////////////////////////////////////////////////////////////////////////////////////////////
// APP 
/////////////////////////////////////////////////////////////////////////////////////////////////

	let rawData=[], intents=[], session=[], keyWords=[], vocab=[]; uvocab=[];
	let nlp=new NLP();																				// Alloc NLP class
	let ws=null;																					// Socket server				
	let aiType="wit";																				// AI type

	let modelName="Activity3";																		// AI Model to use
	let witToken={};
	witToken.Space=  "ZS2-X-HDBR57B-X-O6JWK37PVPODW-X-RXXMGA4FN".replace(/-X-/g,"");				// Space service access token
	witToken.Fiction="AH7-X-LA4QMUA-X-K6C4JCH7V7SH6-X-ULUGH6WTE".replace(/-X-/g,"");				// Fiction service access token
	witToken.Activity3="CK5DKYH-X-DQJJ23R-X-ADW6R5T66BAD-X-ZEE6KO".replace(/-X-/g,"");				// Avitivity 3
	
	$(document).ready(function() {								           							// ON PAGE LOADED
		LoadConfig();																				// Load config file
		InitSocketServer();
		$("#lz-testData").on("click",()=>  	  { $("#lz-testFile").trigger("click");    } );			// ON TEST TRAINING DATA
		$("#lz-deleteData").on("click", ()=>  { DeleteTrainingData();     } );						// ON DELETE TRAINING DATA
		$("#lz-trainData").on("click", ()=>   { if (window.location.host == "localhost") $("#lz-trainFile").trigger("click")}); 	// ON TRAIN DATA		
		$("#lz-importData").on("click",()=>   { $("#lz-tempFile").trigger("click"); 	});			// ON IMPORT
		$("#lz-dataset").on("change", ()=>    { modelName=$("#lz-dataset").val()		});			// ON DATASET CHANGE
		$("#lz-aiType").on("change", ()=>     { aiType=$("#lz-aiType").val().toLowerCase()	});		// ON AI CHANGE
				
		$("#lz-tempFile").on("change",(e)=>{														// ON TEMP FILE LOAD
			ImportCSV(e);																			// Read file
			$("#lz-tempFile").val("");																// Clear value		
			});
		$("#lz-trainFile").on("change",(e)=>{														// ON TRAIN FILE LOAD
			TrainData(e);																			// Read file
			$("#lz-trainFile").val("");																// Clear value		
			});
		$("#lz-testFile").on("change",(e)=>{														// ON TEST FILE LOAD
			TestData(e);																			// Read file
			$("#lz-testFile").val("");																// Clear value		
			});

		$("#lz-utter").on("change",(e)=>{															// ON TEST REMARK
			InferIntents([{text:$("#lz-utter").val()}],(r)=>{
				trace(r)
				$("#lz-result").html(`<b>${r.intent}</b> at ${Math.round(r.confidence*100)}%`);
				});
			});

		$(window).on("keydown",function(e) {														// HANDLE KEYPRESS
			if ((e.which == 81) && e.ctrlKey)	{										// Test key (CTL-Q)
				Test500s();
				}
			});
	});

	function LoadConfig(dataset="Newdata")														// LOAD CONFIG FILE
	{	
		let i;
		rawData=[]; intents=[]; keyWords=[]; vocab=[];												// Reset
		fetch('data/config-1.csv')																	// Load file
			.then(res => res.text())																// Get as text
			.then(res =>{																			// Process																	
				let d=Papa.parse(res, { header:true, skipEmptyLines:true }).data;					// Parse CSV using papa lib
				for (i=0;i<d.length;++i) 															// For each line
					 nlp.AddSyns(d[i].type,d[i].id,d[i].text.split(",")); 							// Add synonyms, keywords, keytags, vocab
				LoadRawData("data/"+dataset+".csv");												// Load raw data file
			});
		}
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
////////////////////////////////////////////////////////////////////////////////////////////////////////// RASA	
	
	
	function LoadRawData(file)																	// LOAD RAW DATA CSV
	{
		fetch(file)																					// Load file
			.then(res => res.text())																// Get as text
			.then(res =>{																			// Process																	
				rawData=Papa.parse(res, { header:true, skipEmptyLines:true }).data;					// Parse CSV using papa lib
				GetKeyWords();																		// Get keywords
				ParseData();																		// Parse data and show stats
			});
	}

	function ParseData()																		// PARSE DATA AND SHOW DATA STATS
	{
		let i,o,kill;
		let nRemarks=0, nResponses=0; 																// Counts
		for (i=0;i<rawData.length;++i) {															// For each entry
			kill=0;																					// Assume we keep it
			o=rawData[i];																			// Point at line
			o.text=nlp.CleanText(o.text);															// Clean text
			if (o.speaker == "Teacher") {															// A remark
				if (o.text.split(" ").length < 4)	continue;										// Skip short remarks
				if (!o.clean_intent)				o.text=nlp.CleanText(o.text);					// No flag set
				else if (o.clean_intent <= 0)		{ rawData.splice(i,1); continue; }				// Remove bad remark
				else if (o.clean_intent == 1)		o.text=nlp.CleanText(o.clean_text);				// Get cleaned text			
				else if (o.clean_intent == 2)		o.text=nlp.CleanText(o.revised);				// Get revised text			
				++nRemarks;																			// Add to count											
				if (!intents["r"+Math.floor(o.intent)]) intents["r"+Math.floor(o.intent)]=[];		// Create base intent holder
				if (!intents["r"+o.intent]) intents["r"+o.intent]=[];								// Create full holder
				intents["r"+Math.floor(o.intent)].push(i);											// Add base index
				intents["r"+o.intent].push(i);														// Add full
				}
			else{																					// A student response
				++nResponses;																		// Add response
				}
			}
		
		let str=`<table>
		<tr><td><b>Number of remarks</b>:</td><td>${nRemarks}</td></tr>
		<tr><td><b>Number of responses</b>: &nbsp; </td><td>${nResponses}</td></tr>`
		str+=getIntents()+"</table>";																// Get number of intents
	//	$("#outp").html(str.replace(/\t|\n|\r/g,""));												// Show stats

		function getIntents() {																		// GET INTENTS
			let i,j,s="";
			for (i=0;i<1000;i+=10) 																	// For each intent
				if (intents["r"+i]) 																// If it exists	
					s+=`<tr><td><b>Intent ${i}</b>:</td><td>${intents["r"+i].length}</td><td>${getSubIntents(i)}</td></tr>`;
			return s;																				// Return intent line
			}

		function getSubIntents(base) {																// GET NUMBER OF SUB INTENTS
			let i,s="( &nbsp;";
			for (i=1;i<10;++i) 																		// For for subs
				if (intents["r"+base+"."+i]) 														// If it exists	
					s+=i+"="+intents["r"+base+"."+i].length+" &nbsp;";								// Add to string
			return s+")";																			// Return subs
			}
	}		

	function GetKeyWords()																		// GET UNIQUE LIST OF WORDS
	{
		let i,j,k,v,s;
		keyWords=[];																				// Clear array
		for (i=0;i<rawData.length;++i) {															// For each line
			if (!rawData[i].text) continue;															// Nothing there
			v=nlp.Tokenize(rawData[i].text);														// Clean and tokenize line
			for (j=0;j<v.length;++j) 																// For each word															
				keyWords.push(v[j]);																// Add to key word list	
			}
		keyWords=[... new Set(keyWords)];															// Make unique

		for (k=100;k<600;k+=100) {																	// Top series
			vocab["r"+k]=[];																		// Start fresh
			for (i=0;i<rawData.length;++i) {														// For each line
				if (!rawData[i].text)										continue;				// Nothing there
				if (rawData[i].speaker != "Teacher") 						continue;				// Only teachers
				if (Math.floor(Math.floor(rawData[i].intent/100)*100) != k) continue;				// Only this intent's 100s level
				v=nlp.Tokenize(rawData[i].text.toLowerCase());										// Tokenize line
				for (j=0;j<v.length;++j)  if (v[j].length > 4) vocab["r"+k].push(v[j]);				// Add to key word list	
				}
			vocab["r"+k]=[... new Set(vocab["r"+k])];												// Make unique
			}
return;
		uvocab=[];
		uvocab["r500"]=vocab["r500"].filter(x => ![...vocab["r100"],...vocab["r200"],...vocab["r300"],...vocab["r400"]].includes(x));
		uvocab["r400"]=vocab["r400"].filter(x => ![...vocab["r100"],...vocab["r200"],...vocab["r300"],...vocab["r500"]].includes(x));
		uvocab["r300"]=vocab["r300"].filter(x => ![...vocab["r100"],...vocab["r200"],...vocab["r400"],...vocab["r500"]].includes(x));
		uvocab["r200"]=vocab["r200"].filter(x => ![...vocab["r100"],...vocab["r300"],...vocab["r400"],...vocab["r500"]].includes(x));
		uvocab["r100"]=vocab["r100"].filter(x => ![...vocab["r200"],...vocab["r300"],...vocab["r400"],...vocab["r500"]].includes(x));
		}
	
	async function TrainData(e)																	// TRAIN DATA
	{	
		if (aiType == "wit") {
			TrainWit(e);																			// Load and train data	
			return;
			}
		else if (aiType == "dialog") {
			TrainDialog(e);																			// Load and make training data	
			return;
			}
	}

	async function TestData(e)																	// TEST DATA
	{	
		let i,k,o,v,id,str,s="";
		let file=e.target.files[0];																	// Point at file
		if (!file) 	return;																			// Quit if bad
	
		let reader=new FileReader();																// Init reader
		reader.readAsText(file);																	// Read file
		reader.onload=(e)=>{ 																		// When loaded
			LoadingIcon(true);																		// Show loading icon
			if (aiType == "wit") {																	// If wit
				let count=0,notFound=0;																// Counts
				let d=[],orig=[];
				let v=Papa.parse(e.target.result, { header:true, skipEmptyLines:true }).data;		// Parse CSV using papa lib
				for (i=0;i<v.length;++i)if (v[i].note == "hold")	d.push(v[i]),orig.push(v[i]);	// Only holds
				let tot=d.length;																	// Total
				InferIntents(d, (res)=>{ 															// On each inference
					i=(tot-d.length-1);																// Current index
					orig[i].intent=orig[i].intent.toLowerCase();									// Force LC
					orig[i].confidence=res.confidence;												// Save confidence
					orig[i].infer=res.intent;														// Save inferred intent
					orig[i].match=(res.intent == orig[i].intent) ? 1 : 0;							// Do they match?
					if (res.confidence < .4)	 orig[i].match=-1;									// Not properly inferred
					count+=orig[i].match;															// Add to count
					trace(res);
					$("#lz-loadingIconText").html("<b>"+Math.floor(i/tot*100)+"%</b>");				// Show progress
					if (!d.length) {																// If last one
						Sound("ding");																// Ding				
						LoadingIcon(false);															// Hide loading icon
						let fields=["intent","remark","note","confidence","infer","match"];			// Field names
						str=Papa.unparse(orig,{ header:true, skipEmptyLines:true, columns:fields });// Make CSV using lib
						SaveTextAsFile("test.csv",str);												// Write file
						let results=[];
						for (i=0;i<orig.length;++i) {												// For each utterance
							if (!results[orig[i].intent]) {											// First one
								results[orig[i].intent]={};											// Add obj
								results[orig[i].intent].tot=0;										// Init
								results[orig[i].intent].match=0;	
								}
							if (orig[i].match != -1) {												// If confidence is high enough
								results[orig[i].intent].match+=orig[i].match;						// Add match
								results[orig[i].intent].tot++;										// Add to count
								}
							else notFound++;														// Add to bad count
							}
						for (o in results) 
							s+=o.toUpperCase()+" "+results[o].match+"/"+results[o].tot+" has "+Math.round(results[o].match/results[o].tot*100)+"% accuracy<br>";	// Intent accuracy
						s+="<br>"+Math.round(count/tot*100)+"% total accuracy";						// Total accuracy
						s+="<br>"+notFound+" Not categorized";										// Uncategorized
						$("#outp").html(s.replace(/\t|\n|\r/g,""));									// Show stats
						return;
					}
					});
				return;
				}

			let nums=[]; nums["*100"]=0; nums["*200"]=0; nums["*300"]=0;	nums["*400"]=0;	nums["*500"]=0;	
			let oks=[];  oks["*100"]=0; oks["*200"]=0;	oks["*300"]=0;	oks["*400"]=0;	oks["*500"]=0	;
			let tots=[],report=[],msgs=[];
			v=e.target.result.split("\n");															// Divide by LF
			for (i=0;i<v.length;++i) {																// For each line
				if (!v[i]) 						continue;											// Skip is nothing there
				if (v[i].match(/- intent: r/))	k=v[i].substr(11).trim();							// Get series
				if (v[i].match(/^   /)) 		msgs.push({ text:v[i].substr(5), intent:k });		// Add if an example
				}
			let tot=msgs.length;																	// Get total to detect
			InferIntents(msgs, (res)=>{ 															// On each inference
				trace(res)
				id=res.intent;																		// Get id	
				nums["*"+Math.floor(id/100)*100]++;													// Advance total count at 100 level
				if (Math.floor(id/100)*100 == Math.floor(res.labeled/100)*100)	oks["*"+Math.floor(id/100)*100]++;	// Add if a match at 100 level
				$("#lz-loadingIconText").html("<b>"+(100-Math.floor(msgs.length/tot*100))+"%</b>");	// Show progress
				str=id+"\t";																		// Coded intent
				str+=(id == res.labeled) ? "   " : " X ";											// Right or wrong?
				str+="\t"+res.labeled;																// Labeled intent
				str+="\t | \t"+res.text;															// Text
				report.push(str);																	// Add to report
				if (!msgs.length) {																	// If last one
					tots["*100"]=oks["*100"]+"/"+nums["*100"]+"="+Math.floor(oks["*100"]/nums["*100"]*100)+"%"; // 100s tally
					tots["*200"]=oks["*200"]+"/"+nums["*200"]+"="+Math.floor(oks["*200"]/nums["*200"]*100)+"%";	// 200s
					tots["*300"]=oks["*300"]+"/"+nums["*300"]+"="+Math.floor(oks["*300"]/nums["*300"]*100)+"%";	// 300s
					tots["*400"]=oks["*400"]+"/"+nums["*400"]+"="+Math.floor(oks["*400"]/nums["*400"]*100)+"%";	// 400s
					tots["*500"]=oks["*500"]+"/"+nums["*500"]+"="+Math.floor(oks["*500"]/nums["*500"]*100)+"%";	// 500s
					Sound("ding");																	// Ding				
					LoadingIcon(false);																// Hide loading icon
					report.sort(); 																	// Sort
					trace(report.join("\n"));														// Show repoport
					trace(tots);																	// Show results
					trace(nums,oks)
					}
				});
			};
	}

	let df={ key:"-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDNg4lVhiuu5Bgy\nimKeyXmb24phJg3yDHZI1YV/SlUq6ZzEX/tgQCPrzHzn6REr4rnbq3Jx54Hi3Wrw\nQY5EDAcSRQPK/6eDFAA1kibsYdlyaeQeUm/qs5cK2vf7c4fIsgGGsCQNzPQZ7Ojp\nwnI7t/+w2LsV1gLprLXDGMkXBRi53OyFExLE9E6ENZMuXdF6dfuD2zuz3Afw43Ej\nxnnqff3o722yWunSo5V22aDmVKVis2lZ1QnRZnqRIHZ/KzzrkTn+A8UnAFwWLAqR\nfff38P4i1bltJyJj0NAGdPqH6Wqv+HwtvV9PvKa01cJQZPzwiQcj9weTCyQOEnhS\nV4bNPzFlAgMBAAECggEAVlBpbK8WR7Tq6McwVmpeFfSl8Nlvv/o1768mC2knzgch\n3WRGio1FyPIwf6JmoNzvnHAsd+R4q9S85j1SSAgZLDYqOqcXLrlGwTkp+du63Q/W\nTFnpQVS+GkQPJN/H5qXEeFIgQl+TIhRbWlpdafGEhTzxjmE9BfGQwWj2hCGS2fRL\n+i8c0L3R4wPkIW/TuuoqzhnQXXyHRhHba1H3LY+jLWcg48LVFUg8m0k+73AIN/wF\nD6cA8B9OmG/mux5tDOTLxABv8TrjwrPrnnRDDqgLskPHuDGhnOP4WMpYQ3jut4So\n6P0on5oRIKflLLefogTVjxO0wIEZrCgXDMn5Ynd9HQKBgQDpjwxUMo2GhDCdUSdr\nz3kufO6HUUtdkgqHsvsvVB7HctQ3Gc3pFkZC9dMcWUlWZOUS7HTOHrNraimjdu5J\nnVcmMOShUJNm9TEe1Q81B9qo2B7o0+6MHqmLdDFiNT9HaJlWYmknGCiInoqTRvL7\n/aCRkPDA8pVNky/P4oMBSMBh4wKBgQDhQqdIXxfgzA8M3I1zFPNaotNPP0LIwmjO\niD8p0Px6yJAZ1uB/AmxaZ5lRI9XvduXnrabpnAWwTCJZiaxvgNekgJ88+JRAuAjl\njpTmDGqAKjaYru9MvmZ9yoRkXKk0u12eS+s/NqH/ILqR2bdiGOpXiLnrVG3Rq1Dl\nfyOHYgTiFwKBgQC1FQ++CCPqc3stvcoOsKGIBZz6lXEVbzFy3LYbj+D9Sm52+i7H\n1VlMeUPg6ukNbtScw3Acj3kUgw8digxeTvtOxQG+gLaIUPpwqUhNGXXTCx2L7yU4\nxl01njTbq+UP/G1GqK5WfUiQBDv0zEGAVrizo+jF8E8KAmBDkZ9402s1eQKBgQCQ\nMDgf7S69qCDiHLM2POzg0WTtTxMSqs6nlTLJM4rJlWQYBiFBa22sGLBc7dFdLQBQ\n4ij7U/GYPcOnCKcl4JUoKWTEhGFxY9veBPxunPf2/g5ggWmP+DhmwKEqFN4CcQSl\n9PaqSfA7/NkvzurBki0+xrgrWKnLEhwAKve1CxsRFQKBgQC6SQ9FjLHrPgODWWhI\nGQaQV5IUtCLCopbkLz4iIDtkVCHBJPjObM+LS6UCY863pEmVe+p+vjAI8FAK4qYB\nWrNFpx7KlpFR39B5n2DVvldLM8/3blEjg/DynxqMe5JcymDHnDEed4RnM7B2D9RX\n0JFxGQCsnmGUPtv/h6gQtls+TQ==\n-----END PRIVATE KEY-----\n",
			 email:"bferster@newagent-xjie.iam.gserviceaccount.com",
			 id: "newagent-xjie"
			}

			df={ key:"-----BEGIN PRIVATE KEY-----\nMIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQDNg4lVhiuu5Bgy\nimKeyXmb24phJg3yDHZI1YV/SlUq6ZzEX/tgQCPrzHzn6REr4rnbq3Jx54Hi3Wrw\nQY5EDAcSRQPK/6eDFAA1kibsYdlyaeQeUm/qs5cK2vf7c4fIsgGGsCQNzPQZ7Ojp\nwnI7t/+w2LsV1gLprLXDGMkXBRi53OyFExLE9E6ENZMuXdF6dfuD2zuz3Afw43Ej\nxnnqff3o722yWunSo5V22aDmVKVis2lZ1QnRZnqRIHZ/KzzrkTn+A8UnAFwWLAqR\nfff38P4i1bltJyJj0NAGdPqH6Wqv+HwtvV9PvKa01cJQZPzwiQcj9weTCyQOEnhS\nV4bNPzFlAgMBAAECggEAVlBpbK8WR7Tq6McwVmpeFfSl8Nlvv/o1768mC2knzgch\n3WRGio1FyPIwf6JmoNzvnHAsd+R4q9S85j1SSAgZLDYqOqcXLrlGwTkp+du63Q/W\nTFnpQVS+GkQPJN/H5qXEeFIgQl+TIhRbWlpdafGEhTzxjmE9BfGQwWj2hCGS2fRL\n+i8c0L3R4wPkIW/TuuoqzhnQXXyHRhHba1H3LY+jLWcg48LVFUg8m0k+73AIN/wF\nD6cA8B9OmG/mux5tDOTLxABv8TrjwrPrnnRDDqgLskPHuDGhnOP4WMpYQ3jut4So\n6P0on5oRIKflLLefogTVjxO0wIEZrCgXDMn5Ynd9HQKBgQDpjwxUMo2GhDCdUSdr\nz3kufO6HUUtdkgqHsvsvVB7HctQ3Gc3pFkZC9dMcWUlWZOUS7HTOHrNraimjdu5J\nnVcmMOShUJNm9TEe1Q81B9qo2B7o0+6MHqmLdDFiNT9HaJlWYmknGCiInoqTRvL7\n/aCRkPDA8pVNky/P4oMBSMBh4wKBgQDhQqdIXxfgzA8M3I1zFPNaotNPP0LIwmjO\niD8p0Px6yJAZ1uB/AmxaZ5lRI9XvduXnrabpnAWwTCJZiaxvgNekgJ88+JRAuAjl\njpTmDGqAKjaYru9MvmZ9yoRkXKk0u12eS+s/NqH/ILqR2bdiGOpXiLnrVG3Rq1Dl\nfyOHYgTiFwKBgQC1FQ++CCPqc3stvcoOsKGIBZz6lXEVbzFy3LYbj+D9Sm52+i7H\n1VlMeUPg6ukNbtScw3Acj3kUgw8digxeTvtOxQG+gLaIUPpwqUhNGXXTCx2L7yU4\nxl01njTbq+UP/G1GqK5WfUiQBDv0zEGAVrizo+jF8E8KAmBDkZ9402s1eQKBgQCQ\nMDgf7S69qCDiHLM2POzg0WTtTxMSqs6nlTLJM4rJlWQYBiFBa22sGLBc7dFdLQBQ\n4ij7U/GYPcOnCKcl4JUoKWTEhGFxY9veBPxunPf2/g5ggWmP+DhmwKEqFN4CcQSl\n9PaqSfA7/NkvzurBki0+xrgrWKnLEhwAKve1CxsRFQKBgQC6SQ9FjLHrPgODWWhI\nGQaQV5IUtCLCopbkLz4iIDtkVCHBJPjObM+LS6UCY863pEmVe+p+vjAI8FAK4qYB\nWrNFpx7KlpFR39B5n2DVvldLM8/3blEjg/DynxqMe5JcymDHnDEed4RnM7B2D9RX\n0JFxGQCsnmGUPtv/h6gQtls+TQ==\n-----END PRIVATE KEY-----\n",
  				email: "newagent-xjie-iam@newagent-xjie.iam.gserviceaccount.com",	
				id: "newagent-xjie"
	
			}


	async function InferIntents(msgs, callback)													// GET RESPONSE FROM AI
	{
		try {
		let m=msgs.shift();																			// Remove from list
		let inference={ text:m.text, labeled:m.intent, intent:0, confidence:0 };					// Null inference
		if (aiType == "rasa") {																		// If RASA
			const response=await fetch("https://lizasim.com:5005/model/parse", {					// Fetch data
				method:"POST",																		// POST
				body: JSON.stringify({text:m.text})													// Payload	
				});
			let res=await response.json();															// Get response 
			inference.intent=res.intent.name.substr(1);												// Intent																		
			inference.confidence=res.intent.confidence;												// Confidence
			inference.labeled=m.intent;																// Labeled intent
			callback(inference);																	// Return inference object
			if (msgs.length) InferIntents(msgs, callback)											// Recurse, if not last
			}
		else if (aiType == "dialog") {																// If DIALOGFLOW
			let p=new Promise((resolve, reject) => {
				setTimeout(()=>{ws.send("1|DIALOGFLOW|ADMIN|INFER|"+df.id+"|"+df.email+"|"+df.key+"|"+m.text.substring(0,255))},500);
				ws.onmessage=(e)=>{ 																// If a ws message
					if (!e.data)			 return;												// Quit if no data
					let v=event.data.split("|");													// Get params
					if (v[1] != "DIALOGFLOW") return;												// Not a dialogflow inference
					resolve(v) };																	// Resolve promise
				}).then(res =>{ 																	// On resolution
					inference.intent=res[2].substr(1);												// Intent																		
					inference.confidence=res[3];													// Confidence
					callback(inference); 															// Return inference
					if (msgs.length) InferIntents(msgs, callback)									// Recurse, if not last
					});
			}
		else if (aiType == "wit") {																	// If WIT
			let url="https://api.wit.ai/message?v=20210922&n=3&q="+m.text.substring(0,255);			// URL			
			const response=await fetch(url, { headers:{ Authorization:'Bearer '+witToken[modelName], 'Content-Type':'application/json'} });	// Send remark to wit
			let res=await response.json();															// Get response
			if (res.intents.length) {																// If an intent found
				inference.intent=res.intents[0].name;												// Get intent																		
				inference.confidence=res.intents[0].confidence;										// Confidence
				}	
			trace(res)
			let str="<b>OTHER INTENTS:</b><br>";
			for (let i=1;i<res.intents.length;++i) 
				str+=Math.floor(res.intents[i].confidence*100)+"% "+res.intents[i].name+"<br>";
			$("#outp").html(str);

			callback(inference);																// Return response
			if (msgs.length) setTimeout(()=>{ InferIntents(msgs, callback);},200);				// Recurse, if not last and add delay
			}
		} catch(e) {trace(e)}
	} 

	function InitSocketServer()																	// INIT SOCKET SERVER
	{
		if (window.location.host == "localhost") ws=new WebSocket('ws://'+window.location.host+':8080');	// Open insecure websocket											
		else									 ws=new WebSocket('wss://'+window.location.host+':8082');	// Secure											
		ws.onclose=()=>   { console.log('disconnected'); ws=null; Sound("delete") };				// ON CLOSE
		ws.onerror=(e)=>  { console.log('error',e);	};												// ON ERROR
		ws.onopen=()=> 	  { console.log('connected'); };											// ON OPEN
	}
	
/////////////////////////////////////////////////////////////////////////////////////////////////
// OUTPUT 
/////////////////////////////////////////////////////////////////////////////////////////////////

	function FindPreviousResponse(ind)															// GET PREVIOUS STUDENT RESPONSE
	{
		while (--ind >= 0) {																		// Search backwards
			if (rawData[ind].speaker != "Teacher") 													// If not a teacher
				return rawData[ind].text;															// Return previous response
			}
		return "";																					// No previous response
	}

	function DeleteTrainingData()															// DELETE TRAINING DATA
	{
		if (window.location.host != "localhost") 	return;											// Only local can delete
		ConfirmBox("Are your sure?","",()=>{
			WitGetUtterances((d)=>{
				WitDeleteUtternances(d,(r)=>{ trace(r);	});
				});
			WitGetIntents((d)=>{
				WitDeleteIntents(d,(r)=>{ trace(r);	});
				});
			})
	}

	function ImportCSV(e) {																		// IMPORT SESSION FROM CSV
		let i,d="";
		let file=e.target.files[0];																	// Point at file
		if (!file) 	return;																			// Quit if bad
		let reader=new FileReader();																// Init reader
		reader.readAsText(file);																	// Read file
		reader.onload=(e)=>{ 																		// When loaded
			let csv=Papa.parse(e.target.result, { header:false, skipEmptyLines:true }).data;		// Parse CSV using papa lib
			for (i=0;i<csv.length;++i) {															// For each line
				if (csv[i][8] == "Teacher")	{														// Only remarks
					if (csv[i][11] == "1") 		s=csv[i][11];										// Original correction
					else if (csv[i][11] == "2") s=csv[i][13];										// Double correction
					else						s=csv[i][10];										// No correction, use original
					if (s.length < 4)			continue;											// Skip if too short
					s=nlp.CleanRemark(s);															// Make line	
					d+="    - "+s+"\n";																// Add
					}
				}
			trace(d)
			Sound("ding");																			// Ding
			};
	}

	function SaveResponseFile(f)																// EXTRACT AND SAVE STUDENT RESPONSES
	{
		let i,v=[];
		let fields=["intent","student","response","valued","language","knowledge","thinking","action","understanding","responseType"];			// Field names
		for (i=0;i<f.length;++i) 																	// For each responses
			if (f[i].response &&  f[i].intent) v.push(f[i]);										// If there, add it
		let str=Papa.unparse(v,{ header:true, skipEmptyLines:true, columns:fields });				// Make CSV using lib
		SaveTextAsFile("responses.csv",str);														// Write file
	}

//
///////////////////////////////////////////////////////////////////////////////////////////////
// WIT
/////////////////////////////////////////////////////////////////////////////////////////////////

	async function TrainWit(e)																	// TRAIN WIT
	{	
		let file=e.target.files[0];																	// Point at file
		if (!file) 	return;																			// Quit if bad
		let reader=new FileReader();																// Init reader
		reader.readAsText(file);																	// Read file
		reader.onload=(e)=>{ 																		// When loaded
			LoadingIcon(true);																		// Show loading icon
			let i,d=Papa.parse(e.target.result.replace(/[!|?]/g,"."),{ header:true, skipEmptyLines:true }).data;	// Parse CSV using papa lib
			SaveResponseFile(d);																	// Save student responses to new CSV file			
			for (i=0;i<d.length;++i) {																// For each remark
				if (d[i].note == "hold") { d.splice(i,1); continue; }								// Remove holds
				if (!d[i].remark) 		 { d.splice(i,1); continue; }								// No remark
				if (!d[i].intent) 		 { d.splice(i,1); continue; }								// No intent
			}
			let tot=d.length;																		// Total

			
			WitTrain(d, (r1,r2)=>{																	// Start sending via recursion		
				trace(r1,r2);																		// Log	
				$("#lz-loadingIconText").html("<b>"+(100-Math.floor(d.length*100/tot))+"%</b>");	// Show progress
				if (!d.length) {																	// If last one
					Sound("ding");																	// Ding				
					LoadingIcon(false);																// Hide loading icon
					}
				});											
			};

	}
	
	function WitGetUtterances(callback)															// GET ARRAY OF UTTERANCES
	{
		const url="https://api.wit.ai/utterances?v=20210922&limit=10000";							// URL 
		const response=fetch(url, { 																// Send command to wit
			  headers: { Authorization:'Bearer '+witToken[modelName], 'Content-Type':'application/json'} 
			  })	
			.then(res => res.json()).then(res =>{callback(res); });									// Send data back
	}

	function WitGetIntents(callback)																// GET ARRAY OF INTNTS
	{
		const url="https://api.wit.ai/intents?v=20210922&limit=10000";								// URL 
		const response=fetch(url, { 																// Send command to wit
			  headers: { Authorization:'Bearer '+witToken[modelName], 'Content-Type':'application/json'} 
			  })	
			.then(res => res.json()).then(res =>{callback(res); });									// Send data back
	}

	function WitDeleteUtternances(utterances, callback)											// DELETE UTTERANCES FROM< SERVER
	{
		const url="https://api.wit.ai/utterances?v=20210922";										// URL 
		const response=fetch(url, { 																// Send command to wit
			  method:"DELETE",
			  headers: { Authorization:'Bearer '+witToken[modelName], 'Content-Type':'application/json'}, 
			  body: JSON.stringify(utterances)
			  })	
		  .then(res => res.json()).then(res =>{callback(res); });									// Send data back
	}

	function WitDeleteIntents(intebts, callback)												// DELETE UTTERANCES FROM SERVER
	{
	return
		const url="https://api.wit.ai/intents?v=20210922";											// URL 
		const response=fetch(url, { 																// Send command to wit
			  method:"DELETE",
			  headers: { Authorization:'Bearer '+witToken[modelName], 'Content-Type':'application/json'}, 
			  body: JSON.stringify(intents)
			  })	
		  .then(res => res.json()).then(res =>{callback(res); });									// Send data back
	}

	async function WitTrain(msgs, callback)														// SEND REMARK TO WIT TO TRAIN
	{
	
//		for (let i=480;i<600;i+=10) 	SaveTextAsFile("r"+i+".json",`{ "name": "r${i}" }`);	
		
		let inference={ text:"", intent:0, confidence:0 };											// Null inference
		let m=msgs.shift();																			// Remove from list and save first
		if (!isNaN(m.intent)) m.intent="r"+m.intent;												// Numbers need to be prefixed with a letter
		const url="https://api.wit.ai/utterances?v=20210922";										// URL 
		let body=[{ text:m.remark.substring(0,255), intent:m.intent.toLowerCase(), entities:[], traits: [] }];	// Make body
		const response=await fetch(url, { 															// Send remark to wit
			  method:"POST",
			  headers: { Authorization:'Bearer '+witToken[modelName], 'Content-Type':'application/json'}, 
			  body: JSON.stringify(body)
			  });	
		let res=await response.json();																// Get response
		callback(m,res);																			// Return responss
		if (msgs.length) setTimeout(()=>{ WitTrain(msgs, callback) },500);							// Recurse, if not last
	}

	async function WitAddIntents(msgs, callback)												// SEND REMARK TO WIT TO TRAIN
	{
	return;
		let inference={ text:"", intent:0, confidence:0 };											// Null inference
		let m=msgs.shift();																			// Remove from list and save first
		if (!isNaN(m.intent)) m.intent="r"+m.intent;												// Numbers need to be prefixed with a letter
		const url="https://api.wit.ai/intents?v=20210922";											// URL 
		let body=[{ name:m.intent.toLowerCase()}];													// Make body
		const response=await fetch(url, { 															// Send remark to wit
			  method:"POST",
			  headers: { Authorization:'Bearer '+witToken[modelName], 'Content-Type':'application/json'}, 
			  body: JSON.stringify(body)
			  });	
		let res=await response.json();																// Get response
		callback(m,res);																			// Return responss
		if (msgs.length) setTimeout(()=>{ WitAddIntents(msgs, callback) },500);						// Recurse, if not last
	}


///////////////////////////////////////////////////////////////////////////////////////////////
// DIALOGFLOW
/////////////////////////////////////////////////////////////////////////////////////////////////
	
	function TrainDialog(e)																		// MAKE DIALOGFLOW INTENT FILE
	{
		let intent,str,i,s;
		let file=e.target.files[0];																	// Point at file
		if (!file) 	return;																			// Quit if bad
		let reader=new FileReader();																// Init reader
		reader.readAsText(file);																	// Read file
		reader.onload=(e)=>{ 																		// When loaded
			let d=Papa.parse(e.target.result.replace(/[!|?]/g,"."),{ header:true, skipEmptyLines:true }).data;	// Parse CSV using papa lib
			for (i=0;i<d.length;++i) if (d[i].type == "hold")	d.splice(i,1);						// Remove holds
			let v=groupBy(d,"intent");
			for (intent in v) {
				str="[\n";
				for (i=0;i<v[intent].length;++i) {													// For each one wanted
					s=v[intent][i].remark.replace(/"/g,"");											// No quotes
					s=s.replace(/'/g,"\\u0027");													// Escape apos
					str+=`{ "data": [{ "text": "${s}", "userDefined": false }], "isTemplate": false, "count": 1, "lang": "en", "updated": 0 },\n`;
					}
				str=str.slice(0,-2)+"\n]";
				SaveTextAsFile(intent+"_usersays_en.json",str);										// Write intent file
				}
			};

		function groupBy(arr, property) {
			return arr.reduce((acc, cur) => {
				acc[cur[property]] = [...acc[cur[property]] || [], cur];
				return acc;
				}, {});
			}
	
	}	

///////////////////////////////////////////////////////////////////////////////////////////////
// OPENAI
/////////////////////////////////////////////////////////////////////////////////////////////////

/*

{
  "queryParams": {
    "sentimentAnalysisRequestConfig": {
      "analyzeQueryTextSentiment": true
    }
  },
  "queryInput": {
    "text": {
      "text": "please reserve an amazing meeting room for six people",
      "languageCode": "en-US"
    }
  }
}
	function OAIGet(msg)																	// GET RESPONSE FROM AI
	{
		let body={
		"prompt": "The following is a list of companies and the categories they fall into\n\nFacebook: Social media, Technology\nLinkedIn: Social media, Technology, Enterprise, Careers\nUber: Transportation, Technology, Marketplace\nUnilever: Conglomerate, Consumer Goods\nMcdonalds: Food, Fast Food, Logistics, Restaurants\nFedEx:",
		"temperature": 0,
		"max_tokens": 6,
		"top_p": 1.0,
		"frequency_penalty": 0.0,
		"presence_penalty": 0.0,
		"stop": ["\n"]
		}

		const url="https://api.openai.com/v1/engines/davinci/completions"
		let token="sk-u4nGW65-X-gajLxEDQlh9OTT3BlbkF-X-JHp7xp1JaQ5HJT7Ca3pqs".replace(/-X-/g,"");	// Get token
		fetch(url,{ method:"POST",
			  headers: { Authorization:'Bearer '+token, 'Content-Type':'application/json'}, 
			  body: JSON.stringify(body)
			  })	
	  	.then(res => res.json()).then(res =>{ trace(res); })
	}
*/


/////////////////////////////////////////////////////////////////////////////////////////////////
// HELPERS 
/////////////////////////////////////////////////////////////////////////////////////////////////

	function trace(msg, p1, p2, p3, p4)																// CONSOLE 
	{
		if (p4 != undefined)
			console.log(msg,p1,p2,p3,p4);
		else if (p3 != undefined)
			console.log(msg,p1,p2,p3);
		else if (p2 != undefined)
			console.log(msg,p1,p2);
		else if (p1 != undefined)
			console.log(msg,p1);
		else
			console.log(msg);
	}

	function Sound(sound, mute)																		// PLAY SOUND
	{
		var snd=new Audio();																			// Init audio object
		if (sound.match(/\.mp3/i))		snd=new Audio(sound)											// If an MP3 file
		else							snd=new Audio("img/"+sound+".mp3");								// Use built in mp3
		if (!mute)	{																					// If not initing or muting	
			snd.volume=100/100;																			// Set volume
			snd.play();																					// Play it
			}
		}

	function SaveTextAsFile(file, contents)															// SAVE TEXT TO LOCAL FILE
	{
		if (file.charAt(0) == "*") {																	// If asking
			GetTextBox("Type file name","", file.substr(1), (s)=>{ SaveTextAsFile(s, contents); });		// Ask for name
			return;																						// Quit
			}
		var textFileAsBlob=new Blob([contents], {type:'text/plain'});
		var downloadLink=document.createElement("a");
		downloadLink.download=file;
		downloadLink.innerHTML="Download File";
		downloadLink.href=window.URL.createObjectURL(textFileAsBlob);
	    downloadLink.onclick=()=>{ downloadLink.remove(); };
		downloadLink.style.display="none";
		downloadLink.id="tdll";
		document.body.appendChild(downloadLink);
		downloadLink.click();
	}

	function GetTextBox(title, content, def, callback)											// GET TEXT LINE BOX
	{
		$("#confirmBoxDiv").remove();																	// Remove 
		$("body").append("<div class='lz-confirm' id='confirmBoxDiv'></div>");							// Add box								
		var str="<img src='img/smlogo.png' width='64' style='vertical-align:-8px'/>&nbsp;&nbsp;";								
		str+="<span style='font-size:14px; color:#666'><b>"+title+"</b></span><br><br>";
		str+="<p>"+content+"<p>";
		str+="<p><input class='lz-is' style='width:75%' type='text' id='gtBoxTt' value='"+def+"'></p>";
		str+="<div id='dialogOK' class='lz-bs'>OK</div>";
		str+="<div id='dialogCancel' class='lz-bs' style='margin-left:8px;background-color:#999'>Cancel</div></div>";
		$("#confirmBoxDiv").html(str);																	// Add to div
		$("#gtBoxTt").focus();																			// Focus on button
		$("#gtBoxTt").on("change", function() {	callback($("#gtBoxTt").val()); $("#confirmBoxDiv").remove(); });	// ONE ENTER
		$("#dialogOK").on("click", function() {	callback($("#gtBoxTt").val()); $("#confirmBoxDiv").remove(); });	// ON OK 
		$("#dialogCancel").on("click", function() {	$("#confirmBoxDiv").remove(); });								// ON CANCEL
		}

	function ConfirmBox(title, content, callback, callback2)										// CONFIRMATION BOX
	{
		Sound("ding");																					// Ding sound
		$("#confirmBoxDiv").remove();																	// Remove 
		$("body").append("<div class='lz-confirm' id='confirmBoxDiv'></div>");							// Add dialog												
		var str="<img src='img/smlogo.png' width='64'>";												// Logo							
		str+="<span style='font-size:16px;float:right;color:#b9220a;margin-top:6px'><b>"+title+"</b></span><br>"; // Title
		str+="<p>"+content+"<p>";
		str+="<div style='float:right'><div id='confirmOK' class='lz-bs'>OK</div>";
		str+="<div id='confirmCancel' class='lz-bs' style='margin-left:8px;background-color:#999'>Cancel</div></div>";
		$("#confirmBoxDiv").html(str);	
	
		$("#confirmOK").on("click", function() {														// ON OK BUT
				$("#confirmBoxDiv").remove();															// Remove 
				if (callback)	callback();																// If callback defined, run it
				});

		$("#confirmCancel").on("click", function() {													// ON CANCEL BUT
				$("#confirmBoxDiv").remove();															// Remove 
				if (callback2)	callback2();															// If callback defined, run it
				Sound("delete");																		// Delete sound
				});
	}

	function TimecodeToSeconds(timecode) 														// CONVERT TIMECODE TO MILLISECONDS
	{
		if (!timecode)	return 0;
		let t=0;
		let v=timecode.match(/(\d*):(\d*):(\d*)\.*(\d*)/);											// Parse
//		t+=v[1]*60*60*1000;																			// Get hours
		t+=v[2]*60*1000;																			// Get mins
		t+=v[3]*1000;																				// Get secs
		if (v[4]) t+=v[4]/1000;																		// Ms
		return t;																					// Return time in ms
	}

	function LoadingIcon(mode)																	// SHOW/HIDE LOADING ICON		
	{
		if (!mode) {																				// If hiding
			$("#lz-loadingIcon").remove();															// Remove it
			return;																					// Quit
			}
		let str="<div id='lz-loadingIcon' style='position:absolute;top:calc(50% - 64px);left:calc(50% - 64px);z-index:5000;text-align:center'>";
		str+="<img src='img/loading.gif' width='128'>";												// Img
		str+="<div id='lz-loadingIconText' style='margin-top:-78px;color:#999'></div></div>";		// Progress
		$("body").append(str);																		// Add icon to container
	}

/////////////////////////////////////////////////////////////////////////////////////////////////
// KEYS / VOCAB
/////////////////////////////////////////////////////////////////////////////////////////////////
	let keySyns=[];
	MakeActionKeys()

	function MakeActionKeys()
	{
		let i,v;
		v=(`strategy,strategies,policy,policies,procedure,procedures,approach,approaches,approaching,blueprint,program,stratagem,stratagems,
		plan,plans,planning,guideline,guidance,scheme,schema,organize,organization,tenet,path,pathway,avenue,agenda,agendas,agendum,channel,channels,modus,operandi,maneuver,
		process,prototype,archetype,model,theory,theories,structure,structures,arrange,arrangement,arranging,classify,classification,clue,incorporate,integrate,
		sort,proposal,propose,codify,codification,layout,design,designs,coordinate,create,creating,created,establish,standardize,figured,skill,skills,
		rule,rules,construct,constructs,constructed,constructing,invent,technique,progression,unfolding,architecture,catalog,catalogue,alphabetize,pattern,
		method,manner,mechanism,rubric,routine,scenario,outline,synopsis,summary,summarize,rundown,run-down,review,recap,recapitulation,
		analysis,keyword,keywords,key_word,sequence.chronological,timeline,concept,concepts,conceptualize,context,
		contextualize,revise,revision,sum,sum-up,take-away,takeaway`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`explain,explaining,explains,clarify,simplify,formulate,solve,determine,reason,reasoning,enlighten,decode,descrypt,unscramble,portray,comment,assert,disclose,depict,identify,find,pinpoint,
		expound,exemplify,represent,annotate,annotating,delineate,define,designate,illustrate,reveal,tell,elucidate,paraphrase,unravel,untangle,describe,mean,
		symbolize,exhibit,embody,epitomize,utter,communicate,declare,divulge,impart,notify,specify,expose,proclaim`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`opine,believe,posit,presume,feel,imagine,envisage,envision,visualize,perceive,anticipate,foresee,realize,suppose,pretend,hypothesis,
		hypothesize,speculate,estimate,presuppose,judge,guess,divine,stab,surmise,	rekon,decipher,deduce,infer,postulate,venture,conjecture,predict,
		guesstimate,ascertain`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`understand,glean,know,get,comprehend,comprehension,learn,fathom,deem,grasp,master,point,recognize,distinguish,information,inform`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`prior,previous,previously,back`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`compare,correlate,contrast,diverge,vary,equal,than,less,fewer,reduced,greater,increrase,increased,higher,added,larger,more,improve,improved,enhance,enhanced,
		raise,raised,better,worse,changed,modify,modified,next,last,later,before,previous,previously,since,former,afterward,afterwards,subsequently,since,after,shift,
		differ,differed,difference`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		v=(`reflect,contemplate,think,consider,interpret,decide,decision,characterize,argue,claim,advocate,suggest,remember,remind,recollect,invoke,
		theorize,suspect,scrutinize,conclude,conclusion,concede,ponder`).replace(/\t|\n|\r/g,"").split(",");
		for (i=0;i<v.length;++i) keySyns[v[i]]="key_500";
		}

</script>
</body>
</html>



