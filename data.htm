<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<link REL="SHORTCUT ICON" HREF="img/favicon.ico">
		<title>dataParser</title>
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
		<script src="lib/papaparse.min.js"></script>
		<script src="nlp.js"></script>
	</head>
	<style>
		body { 	font-family:Segoe UI,Verdana,Geneva,sans-serif;font-size:16px; margin:20px; }
		.co-is 		{	border-radius:16px; padding:0 8px; height: 24px; border:1px solid #999; font-size: 13px; text-align:center; }
		.co-bs 		{	display:inline-block; border-radius:16px; padding:0 16px; border:1px solid #999; font-size: 13px; 
						cursor:pointer; z-index:2; padding-bottom:1px; color:#000; background-color: #eee; font-weight:600; }
		.co-bsg		{	cursor: pointer; color:#fff; text-align: center; border-radius: 16px; display: inline-block; user-select: none;
						font-size: 13px; background-color: #999; padding: 2px 8px 2px 8px; }
		.lz-confirm {	position: absolute;  width: 300px; padding: 16px; left: calc(50% - 150px); top: calc(50% - 50px); user-select: none;	
						border-radius: 8px; background-color: #fff; border: 1px solid #999; box-shadow: 4px 2px 12px 2px #aaa; }
	</style>
	<body>
		<input type="file" id="lz-tempFile" accept=".csv,.CSV" style="display:none">
		<div class="co-bs" id="lz-importData" style="margin:12px">Load session</div>
		<input type="file" id="lz-testFile" accept=".txt" style="display:none">

		<div style="width:66%;margin:0 auto;text-align:center">
			<img src="img/lizalogo.png" style="width:25%">
			<span style="font-size:24px;vertical-align:12px"><b><i> dataparser</b></i></span>
			<hr>
			Dataset: <select class="co-is" id="lz-dataset">
				<option>Newdata</option><option>Cleaned</option><option>Original</option>><option>Testdata</option>
				</select>
			&nbsp &nbsp; Series: <select class="co-is" id="lz-series">
				<option>Hundreds</option><option>Tens</option><option>Decimals</option><option>
			</select>
			&nbsp &nbsp; Max per intent: <input type="input" class="co-is" style="width:40px" value="500" id="lz-num"/>
			&nbsp &nbsp; Test % <input type="input" class="co-is" style="width:40px" value="0" id="lz-holdOut"/>
			<hr><p>
				<div class="co-bs" id="lz-makeTrain">Make nlu.yml</div>
				&nbsp; &nbsp; &nbsp;<div class="co-bs" id="lz-testData">Test data</div>
				&nbsp; &nbsp; &nbsp;<div class="co-bs" id="lz-makeSession">Make session</div>
				&nbsp;<input type="input" class="co-is" style="width:40px" value="78" id="lz-session"/>
			</p>
			<hr>
			<p id="outp" style="text-align:left"></p>
		</div>
	
<script>

/////////////////////////////////////////////////////////////////////////////////////////////////
// APP 
/////////////////////////////////////////////////////////////////////////////////////////////////

	let rawData=[], intents=[], session=[], keyWords=[], vocab=[]; uvocab=[];
	let nlp=new NLP();																				// Alloc NLP class

	$(document).ready(function() {								           						// ON PAGE LOADED
		LoadConfig();																				// Load config file
		$("#lz-makeTrain").on("click",()=>	  { MakeStories(1);    } );								// ON MAKE NLU ILE
		$("#lz-makeSession").on("click", ()=> { MakeSession();     } );								// ON MAKE SESSION
		$("#lz-testData").on("click", ()=> 	  { $("#lz-testFile").trigger("click"); 	});			// ON TEST DATA
		$("#lz-importData").on("click",()=>   { $("#lz-tempFile").trigger("click"); 	});			// ON IMPORT
		$("#lz-dataset").on("change", ()=>    { LoadConfig($("#lz-dataset").val()) 		});			// ON DATASET
				
		$("#lz-tempFile").on("change",(e)=>{														// ON FILE LOAD
			ImportCSV(e);																			// Read file
			$("#lz-tempFile").val("");																// Clear value		
			});
		$("#lz-testFile").on("change",(e)=>{														// ON TEST FILE LOAD
			TestData(e);																			// Read file
			$("#lz-tempFile").val("");																// Clear value		
			});
		$(window).on("keydown",function(e) {														// HANDLE KEYPRESS
			if ((e.which == 84) && e.altKey && e.ctrlKey)	{										// Test key (Ctrl+Alt+T)
				GetTextBox("Type intent","","",(s)=>{ WitTrainIntent(s); });	
				}
			});
		});

	function LoadConfig(dataset="Newdata")														// LOAD CONFIG FILE
	{	
		let i;
		rawData=[]; intents=[]; keyWords=[]; vocab=[];												// Reset
		fetch('data/config.csv')																	// Load file
			.then(res => res.text())																// Get as text
			.then(res =>{																			// Process																	
				let d=Papa.parse(res, { header:true, skipEmptyLines:true }).data;					// Parse CSV using papa lib
				for (i=0;i<d.length;++i) 															// For each line
					 nlp.AddSyns(d[i].type,d[i].id,d[i].text.split(",")); 							// Add synonyms, keywords, keytags, vocab
				LoadRawData("data/"+dataset+".csv");												// Load raw data file
			});
		}
	
	function LoadRawData(file)																	// LOAD RAW DATA CSV
	{
		fetch(file)																					// Load file
			.then(res => res.text())																// Get as text
			.then(res =>{																			// Process																	
				rawData=Papa.parse(res, { header:true, skipEmptyLines:true }).data;					// Parse CSV using papa lib
				GetKeyWords();																		// Get keywords
				ParseData();																		// Parse data and show stats
			});
	}

	function ParseData()																		// PARSE DATA AND SHOW DATA STATS
	{
		let i,o,kill;
		let nRemarks=0, nResponses=0; 																// Counts
		for (i=0;i<rawData.length;++i) {															// For each entry
			kill=0;																					// Assume we keep it
			o=rawData[i];																			// Point at line
			o.text=nlp.CleanText(o.text);															// Clean text
			if (o.speaker == "Teacher") {															// A remark
				if (o.text.split(" ").length < 4)	continue;										// Skip short remarks
				if (!o.clean_intent)				o.text=nlp.CleanText(o.text);					// No flag set
				else if (o.clean_intent <= 0)		{ rawData.splice(i,1); continue; }				// Remove bad remark
				else if (o.clean_intent == 1)		o.text=nlp.CleanText(o.clean_text);				// Get cleaned text			
				else if (o.clean_intent == 2)		o.text=nlp.CleanText(o.revised);				// Get revised text			
				++nRemarks;																			// Add to count											
				if (!intents["r"+Math.floor(o.intent)]) intents["r"+Math.floor(o.intent)]=[];		// Create base intent holder
				if (!intents["r"+o.intent]) intents["r"+o.intent]=[];								// Create full holder
				intents["r"+Math.floor(o.intent)].push(i);											// Add base index
				intents["r"+o.intent].push(i);														// Add full
				}
			else{																					// A student response
				++nResponses;																		// Add response
				}
			}
		
		let str=`<table>
		<tr><td><b>Number of remarks</b>:</td><td>${nRemarks}</td></tr>
		<tr><td><b>Number of responses</b>: &nbsp; </td><td>${nResponses}</td></tr>`
		str+=getIntents()+"</table>";																// Get number of intents
		$("#outp").html(str.replace(/\t|\n|\r/g,""));												// Show stats

		function getIntents() {																		// GET INTENTS
			let i,j,s="";
			for (i=0;i<1000;i+=10) 																	// For each intent
				if (intents["r"+i]) 																// If it exists	
					s+=`<tr><td><b>Intent ${i}</b>:</td><td>${intents["r"+i].length}</td><td>${getSubIntents(i)}</td></tr>`;
			return s;																				// Return intent line
			}

		function getSubIntents(base) {																// GET NUMBER OF SUB INTENTS
			let i,s="( &nbsp;";
			for (i=1;i<10;++i) 																		// For for subs
				if (intents["r"+base+"."+i]) 														// If it exists	
					s+=i+"="+intents["r"+base+"."+i].length+" &nbsp;";								// Add to string
			return s+")";																			// Return subs
			}
	}		

	function GetKeyWords()																		// GET UNIQUE LIST OF WORDS
	{
		let i,j,k,v,s;
		keyWords=[];																				// Clear array
		for (i=0;i<rawData.length;++i) {															// For each line
			if (!rawData[i].text) continue;															// Nothing there
			v=nlp.Tokenize(rawData[i].text);														// Clean and tokenize line
			for (j=0;j<v.length;++j) 																// For each word															
				keyWords.push(v[j]);																// Add to key word list	
			}
		keyWords=[... new Set(keyWords)];															// Make unique

		for (k=100;k<600;k+=100) {																	// Top series
			vocab["r"+k]=[];																		// Start fresh
			for (i=0;i<rawData.length;++i) {														// For each line
				if (!rawData[i].text)										continue;				// Nothing there
				if (rawData[i].speaker != "Teacher") 						continue;				// Only teachers
				if (Math.floor(Math.floor(rawData[i].intent/100)*100) != k) continue;				// Only this intent's 100s level
				v=nlp.Tokenize(rawData[i].text.toLowerCase());										// Tokenize line
				for (j=0;j<v.length;++j)  if (v[j].length > 4) vocab["r"+k].push(v[j]);				// Add to key word list	
				}
			vocab["r"+k]=[... new Set(vocab["r"+k])];												// Make unique
			}
return;
		uvocab=[];
		uvocab["r500"]=vocab["r500"].filter(x => ![...vocab["r100"],...vocab["r200"],...vocab["r300"],...vocab["r400"]].includes(x));
		uvocab["r400"]=vocab["r400"].filter(x => ![...vocab["r100"],...vocab["r200"],...vocab["r300"],...vocab["r500"]].includes(x));
		uvocab["r300"]=vocab["r300"].filter(x => ![...vocab["r100"],...vocab["r200"],...vocab["r400"],...vocab["r500"]].includes(x));
		uvocab["r200"]=vocab["r200"].filter(x => ![...vocab["r100"],...vocab["r300"],...vocab["r400"],...vocab["r500"]].includes(x));
		uvocab["r100"]=vocab["r100"].filter(x => ![...vocab["r200"],...vocab["r300"],...vocab["r400"],...vocab["r500"]].includes(x));
		}
	
	function TestData(e)																		// TEST DATA
	{	
		let i,k,o,v,ins=0,tot=3,str="";
		let file=e.target.files[0];																	// Point at file
		if (!file) 	return;																			// Quit if bad
		let reader=new FileReader();																// Init reader
		reader.readAsText(file);																	// Read file
		reader.onload=(e)=>{ 																		// When loaded
			LoadingIcon(true);																		// Show loading icon
			let nums=[]; nums["*100"]=0; nums["*200"]=0; nums["*300"]=0;	nums["*400"]=0;	nums["*500"]=0;	
			let oks=[];  oks["*100"]=0; oks["*200"]=0;	oks["*300"]=0;	oks["*400"]=0;	oks["*500"]=0	;
			let tots=[];	report=[]
			v=e.target.result.split("\n")
			for (i=0;i<v.length;++i) {																// For each line
				if (!v[i]) continue;
				if (v[i].match(/- intent: r/))	k=v[i].substr(11).trim();							// Get series
				if (v[i].match(/^   /)) {
					ins++;																			// Sent one
					GetResponse2(v[i].substr(5), k, (res, id)=>{
						nums["*"+id]++;																// Advance total count
						if (id == res.intent.name.substr(1))	oks["*"+id]++;
						tots["*100"]=oks["*100"]+"/"+nums["*100"]+"="+Math.floor(oks["*100"]/nums["*100"]*100)+"%";
						tots["*200"]=oks["*200"]+"/"+nums["*200"]+"="+Math.floor(oks["*200"]/nums["*200"]*100)+"%";
						tots["*300"]=oks["*300"]+"/"+nums["*300"]+"="+Math.floor(oks["*300"]/nums["*300"]*100)+"%";
						tots["*400"]=oks["*400"]+"/"+nums["*400"]+"="+Math.floor(oks["*400"]/nums["*400"]*100)+"%";
						tots["*500"]=oks["*500"]+"/"+nums["*500"]+"="+Math.floor(oks["*500"]/nums["*500"]*100)+"%";
						$("#lz-loadingIconText").html("<b>"+(100-Math.floor(ins/tot*100))+"%</b>");	// Show progress
						str=id;																		// Coded intent
						str+=(id == res.intent.name.substr(1)) ? "   " : " X ";						// Right or wrong?
						str+=res.intent_ranking[0].name.substr(1);									// Main intent
						str+=" | "+res.intent_ranking[1].name.substr(1);							// 2nd choice
//						str+=" | "+res.intent_ranking[2].name.substr(1);							// 3rd choice
						str+=" | "+res.text;														// Text
						report.push(str);															// Add to report
						trace(tots);															// Show results
						if (!--ins)	{																// If last
							Sound("ding");															// Ding				
							LoadingIcon(false);														// Show loading icon
							report.sort(); 															// Sort
							trace(report.join("\n"));												// Show results
							trace(tots);															// Show results
							}
						})
					}
				}
			tot=ins;																				// Total sent
		}
	}

	function GetResponse2(msg, id, callback)														// GET RESPONSE FROM AI
	{
		let xhttp=new XMLHttpRequest();																// Alloc hxmlhttp
		xhttp.onreadystatechange = function() {														// ON STATE CHANGE
			if (this.readyState == 4 && this.status == 200) {										// Valid response
				let o=JSON.parse(this.response);													// Objectify
	//			trace(o);																			// Log
				if (callback) callback(o,id);														// Run callback
					return;																			// Quit
				}
			};
		xhttp.open("POST", "https://lizasim.com:5005/model/parse");									// Set url
		xhttp.setRequestHeader("Content-Type", "application/json");									// Set type
		xhttp.send(JSON.stringify({text:msg}));														// Set paqyload
		}



/////////////////////////////////////////////////////////////////////////////////////////////////
// OUTPUT 
/////////////////////////////////////////////////////////////////////////////////////////////////

	function FindPreviousResponse(ind)															// GET PREVIOUS STUDENT RESPONSE
	{
		while (--ind >= 0) {																		// Search backwards
			if (rawData[ind].speaker != "Teacher") 													// If not a teacher
				return rawData[ind].text;															// Return previous response
			}
		return "";																					// No previous response
	}

	function MakeStories(mask)																	// MAKE ALL FILES
	{
		let ints=[],doms=[],sess=[],dupes=[];
		let rType,keys=[],resps=[];
		let i,inc,o,c,ss,re,who,id,sid,tot;
		let test=$("#lz-holdOut").val()/100;														// Percent to test
		let level=$("#lz-series").val();															// Level of intents
		let num=$("#lz-num").val();																	// Max per intent
		
//		ints["bot_challenge"]=[]; 	 ints["addition"]=[]; 											// Built-ins
//		ints["bot_challenge"].push("    - are you a bot?"); ints["bot_challenge"].push("    - are you human?");
//		ints["bot_challenge"].push("    - am I talking to a bot?"); ints["bot_challenge"].push("    - am I talking to a human?");
//		ints["addition"].push("    - what is 2+2?"); ints["addition"].push("    - what does 2+2 equal?"); ints["addition"].push("    - what does 2+2 make?"); 
		
		for (i=0;i<rawData.length;++i) {															// For each line
			o=rawData[i];																			// Point at it
			if ((o.intent < 180) || ((o.intent > 181) && (o.intent < 250))) continue;				// Cull 181-300
\			if (nlp.Tokenize(o.text).length < 4)			continue;								// Skip if short
			if (level == "Decimals") 		id=o.intent;											// Make full intent id name
			else if (level == "Tens")		id=Math.floor(o.intent);								// Cap at 10s					
			else							id=Math.floor(o.intent/100)*100;						// Cap at 100s
			
			sid="session-"+o.rerid;																	// Session id
			if (!sess[sid]) 			  	sess[sid]=[];											// Alloc session holder
			if (o.speaker == "Teacher") {															// If remark
				keys=nlp.Tokenize(o.text).filter(value => keyWords.includes(value));				// Get keys mentioned
				if (id < 100)	continue;															// Skip if uncoded
				id="r"+id;																			// Prefix id
				if (!ints[id]) ints[id]=[];															// Alloc intent holder
				sess[sid].push("  - intent: "+id+"\n");												// Add intent to story
				ss=nlp.CleanRemark(o.text,FindPreviousResponse(i));									// Get clean text
				who=nlp.GetWho(o.text);																// Get who
				ints[id].push("    - "+ss.trim());													// Add it
				} 
			else{																					// Response
				rType="agree";
				if (isNaN(id)) {																	// Ignore numbered responses for now
					resps.push( { intent:id,text: o.text.trim().replace(/:|"/g,""),keys:keys,type:rType,turn:Math.floor(i/2),speaker:who.split(":")[1] });
					sess[sid].push("  - action: utter_r"+i+"\n");									// Add response to story
					doms.push(`\n  utter_r${i}:\n  - text: "${o.text.trim().replace(/:|"/g,"")}"\n`);	// Add to domain file
				}
			}
		}

		for (k in ints)	ints[k]=[... new Set(ints[k])];												// Make unique																		// For each intent
		let str="version: \"3.0\"\n\nnlu:\n";														// NLU header
		let v=[],j,str2=str;		
		for (k in ints)	v.push(k);																	// Make normal array of intents
		v=v.sort();																					// Sort them
		for (j=0;j<v.length;++j)	{																// For each intent
			k=v[j];																					// intent name
			tot=Math.floor(Math.min(num,ints[k].length)*(1-test));									// Get amount to train
			inc=Math.max(ints[k].length/num,1);														// Sampling increment, at least 1
			str+="- intent: "+k+"\n  examples: |\n";												// Add header
			str2+="- intent: "+k+"\n  examples: |\n";												// Add header
			for (i=0;i<tot*inc;i+=inc) 																// For each one wanted
				str+=ints[k][Math.floor(i)]+"\n";													// Get it
			for (i=0;i<Math.min(num,ints[k].length)-tot;++i) 										// For each test example
				str2+=ints[k][Math.floor(i+tot)]+"\n";												// Get it
			}
		if (mask&1) 			  SaveTextAsFile("nlu.yml",str);									// Write training file
		if (mask&1 && (test > 0)) SaveTextAsFile("test-nlu.txt",str2);								// Write testing file
	}

	async function MakeSession()																// CREATE SESSION FILE
	{
		let i=0,o,n=rawData.length,data=[];
		let speaker,remark="",response="",intent,student;
		while (i < n) {																				// For each item
			o=rawData[i++];																			// Point at line
			if (o.speaker == "Teacher") {															// If a teacher
				if (!o.intent) continue;															// Skip uncodeds
				remark+=o.text+" ";																	// Add remark
				intent=o.intent;																	// Set last intent
				}				
			else{																					// A student
				--i;
				while (i < n) {																		// Collect all responses
					o=rawData[i];																	// Point at line
					if (o.speaker == "Teacher") break;												// Quit at next remark
					response+=o.text+" ",student=o.speaker;											// Add response and set last student
					++i;																			// Advance
					}
				data.push({ id:o.id,intent:intent,student:student,code:"",remark:remark,response:response} );	// Add to data
				remark=response="";
				}
			}
		let fields=["id","intent","student","remark","response"];							// Field names
		let str=Papa.unparse(data,{ header:true, skipEmptyLines:true, columns:fields });			// Make CSV using lib
		SaveTextAsFile("session.csv",str);														// Write file
		Sound("ding");																				// Sound
/*
		let i,o,s,newint,session=[],texts=[],intents=[],startTime=0;
		let fields=["scene","actor","intent","calc","ok","time","text"];							// Field names
		let sessId=$("#lz-session").val().split("-")[0];											// Session to add
		LoadingIcon(true);																			// Show loading icon
		for (i=0;i<rawData.length;++i) {															// For each line
			o=rawData[i];																			// Point at it
			if (o.rerid != sessId) 	continue;														// Skip if not right session
			if (!startTime)			startTime=TimecodeToSeconds(o.timestamp);						// Set 1st time
			s=nlp.CleanText(o.text);																// Clean
			texts.push(s);																			// Add to array of texts
			t=TimecodeToSeconds(o.timestamp)-startTime;												// Get event time
			if (o.intent) newint=o.intent;															// Get new intent
			session.push({ scene:o.topic, actor:o.speaker, intent:newint, time:t, text:s});			// Add line 
			}
			
		const fetchAll=async(texts) => {															// GET ALL INTENTS AT ONCE
  			let i,n;
			const res   = await Promise.all(texts.map(t => GetResponse(t)));						// Ask for intents
  			const jsons = await Promise.all(res.map(r => r.json()));								// Wait for them
			for (i=0;i<jsons.length;++i) {															// For each line
				n=(jsons[i].intent_ranking[0].name == "nlu_fallback") ? 1 : 0;						// Go to second choice
				session[i].calc=jsons[i].intent_ranking[n].name.substr(1);							// Get intent
				if (Math.floor(session[i].intent/100)*100 == session[i].calc) session[i].ok=1;		// A match
				else														  session[i].ok=0;		// None
				}
			let str=Papa.unparse(session,{ header:true, skipEmptyLines:true, columns:fields });		// Make CSV using lib
			SaveTextAsFile("session-"+sessId+".csv",str);											// Write file
			LoadingIcon(false);																		// Hide loading icon
			Sound("ding");																			// Sound
			}
		fetchAll(texts);																			// Get all intents
*/
	}

	function GetResponse(msg)																	// GET RESPONSE FROM AI
	{
		return fetch("https://lizasim.com:5005/model/parse", {										// Fetch data
			method:"POST",	
			body: JSON.stringify({text:msg})		
			})
	}

	function ImportCSV(e) {																		// IMPORT SESSION FROM CSV
		let i,d="";
		let file=e.target.files[0];																	// Point at file
		if (!file) 	return;																			// Quit if bad
		let reader=new FileReader();																// Init reader
		reader.readAsText(file);																	// Read file
		reader.onload=(e)=>{ 																		// When loaded
			let csv=Papa.parse(e.target.result, { header:false, skipEmptyLines:true }).data;		// Parse CSV using papa lib
			for (i=0;i<csv.length;++i) {															// For each line
				if (csv[i][8] == "Teacher")	{														// Only remarks
					if (csv[i][11] == "1") 		s=csv[i][11];										// Original correction
					else if (csv[i][11] == "2") s=csv[i][13];										// Double correction
					else						s=csv[i][10];										// No correction, use original
					if (s.length < 4)			continue;											// Skip if too short
					s=nlp.CleanRemark(s);															// Make line	
					d+="    - "+s+"\n";																// Add
					}
				}
			trace(d)
			Sound("ding");																			// Ding
			};
	}

/*///////////////////////////////////////////////////////////////////////////////////////////////
// WIT
/////////////////////////////////////////////////////////////////////////////////////////////////

	function WitTrainIntent(intent)
	{
		let i;
		let n=Math.min(intents[intent].length,199);
		for (i=0;i<n;++i)  WitTrain(intent, rawData[i].text)
	}

	function WitTrain(intent, remark)															// SEND REMARK TO WIT
	{
		const url="https://api.wit.ai/utterances?v=20210922";										// URL
		let token="57CTW-X-CFRZYAIGCB-X-PHA6E5QT4-X-FG3IOR6O".replace(/-X-/g,"");					// Get token
		intent=intent.replace(/\./,"_");															// Modify intent to suitb Wit
		let body=[{ text:remark, intent:intent, entities:[], traits: [] }];							// Make body
		trace(body)
		fetch(url,{ method:"POST",
			  headers: { Authorization:'Bearer '+token, 'Content-Type':'application/json'}, 
			  body: JSON.stringify(body)
			  })	
	  	.then(res => res.json()).then(res =>{ trace(res); })
	}
*/
/*
// 107292363236-rc8802iosnbgk2unvd5uf4b010rmlkn5.apps.googleusercontent.com

POST https://dialogflow.googleapis.com/v2/projects/project-id/agent/sessions/123456789:detectIntent


{
  "queryParams": {
    "sentimentAnalysisRequestConfig": {
      "analyzeQueryTextSentiment": true
    }
  },
  "queryInput": {
    "text": {
      "text": "please reserve an amazing meeting room for six people",
      "languageCode": "en-US"
    }
  }
}
	function OAIGet(msg)																	// GET RESPONSE FROM AI
	{
		let body={
		"prompt": "The following is a list of companies and the categories they fall into\n\nFacebook: Social media, Technology\nLinkedIn: Social media, Technology, Enterprise, Careers\nUber: Transportation, Technology, Marketplace\nUnilever: Conglomerate, Consumer Goods\nMcdonalds: Food, Fast Food, Logistics, Restaurants\nFedEx:",
		"temperature": 0,
		"max_tokens": 6,
		"top_p": 1.0,
		"frequency_penalty": 0.0,
		"presence_penalty": 0.0,
		"stop": ["\n"]
		}

		const url="https://api.openai.com/v1/engines/davinci/completions"
		let token="sk-u4nGW65-X-gajLxEDQlh9OTT3BlbkF-X-JHp7xp1JaQ5HJT7Ca3pqs".replace(/-X-/g,"");	// Get token
		fetch(url,{ method:"POST",
			  headers: { Authorization:'Bearer '+token, 'Content-Type':'application/json'}, 
			  body: JSON.stringify(body)
			  })	
	  	.then(res => res.json()).then(res =>{ trace(res); })
	}
*/
/////////////////////////////////////////////////////////////////////////////////////////////////
// HELPERS 
/////////////////////////////////////////////////////////////////////////////////////////////////

	function trace(msg, p1, p2, p3, p4)																// CONSOLE 
	{
		if (p4 != undefined)
			console.log(msg,p1,p2,p3,p4);
		else if (p3 != undefined)
			console.log(msg,p1,p2,p3);
		else if (p2 != undefined)
			console.log(msg,p1,p2);
		else if (p1 != undefined)
			console.log(msg,p1);
		else
			console.log(msg);
	}

	function Sound(sound, mute)																		// PLAY SOUND
	{
		var snd=new Audio();																			// Init audio object
		if (sound.match(/\.mp3/i))		snd=new Audio(sound)											// If an MP3 file
		else							snd=new Audio("img/"+sound+".mp3");								// Use built in mp3
		if (!mute)	{																					// If not initing or muting	
			snd.volume=100/100;																			// Set volume
			snd.play();																					// Play it
			}
		}

	function SaveTextAsFile(file, contents)															// SAVE TEXT TO LOCAL FILE
	{
		if (file.charAt(0) == "*") {																	// If asking
			GetTextBox("Type file name","", file.substr(1), (s)=>{ SaveTextAsFile(s, contents); });		// Ask for name
			return;																						// Quit
			}
		var textFileAsBlob=new Blob([contents], {type:'text/plain'});
		var downloadLink=document.createElement("a");
		downloadLink.download=file;
		downloadLink.innerHTML="Download File";
		downloadLink.href=window.URL.createObjectURL(textFileAsBlob);
	    downloadLink.onclick=()=>{ downloadLink.remove(); };
		downloadLink.style.display="none";
		downloadLink.id="tdll";
		document.body.appendChild(downloadLink);
		downloadLink.click();
	}

	function GetTextBox(title, content, def, callback)											// GET TEXT LINE BOX
	{
		$("#confirmBoxDiv").remove();																	// Remove 
		$("body").append("<div class='lz-confirm' id='confirmBoxDiv'></div>");							// Add box								
		var str="<img src='img/lizalogo.png' width='64' style='vertical-align:-8px'/>&nbsp;&nbsp;";								
		str+="<span style='font-size:14px; color:#666'><b>"+title+"</b></span><br><br>";
		str+="<p>"+content+"<p>";
		str+="<p><input class='lz-is' style='width:75%' type='text' id='gtBoxTt' value='"+def+"'></p>";
		str+="<div id='dialogOK' class='lz-bs'>OK</div>";
		str+="<div id='dialogCancel' class='lz-bs' style='margin-left:8px;background-color:#999'>Cancel</div></div>";
		$("#confirmBoxDiv").html(str);																	// Add to div
		$("#gtBoxTt").focus();																			// Focus on button
		$("#gtBoxTt").on("change", function() {	callback($("#gtBoxTt").val()); $("#confirmBoxDiv").remove(); });	// ONE ENTER
		$("#dialogOK").on("click", function() {	callback($("#gtBoxTt").val()); $("#confirmBoxDiv").remove(); });	// ON OK 
		$("#dialogCancel").on("click", function() {	$("#confirmBoxDiv").remove(); });								// ON CANCEL
		}

	function TimecodeToSeconds(timecode) 														// CONVERT TIMECODE TO MILLISECONDS
	{
		if (!timecode)	return 0;
		let t=0;
		let v=timecode.match(/(\d*):(\d*):(\d*)\.*(\d*)/);											// Parse
//		t+=v[1]*60*60*1000;																			// Get hours
		t+=v[2]*60*1000;																			// Get mins
		t+=v[3]*1000;																				// Get secs
		if (v[4]) t+=v[4]/1000;																		// Ms
		return t;																					// Return time in ms
	}

	function LoadingIcon(mode)																	// SHOW/HIDE LOADING ICON		
	{
		if (!mode) {																				// If hiding
			$("#lz-loadingIcon").remove();															// Remove it
			return;																					// Quit
			}
		let str="<div id='lz-loadingIcon' style='position:absolute;top:calc(50% - 64px);left:calc(50% - 64px);z-index:5000;text-align:center'>";
		str+="<img src='img/loading.gif' width='128'>";												// Img
		str+="<div id='lz-loadingIconText' style='margin-top:-78px;color:#999'></div></div>";		// Progress
		$("body").append(str);																		// Add icon to container
	}


</script>
</body>
</html>

