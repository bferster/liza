<!DOCTYPE html>
<html lang="en">
	<head>
		<title>dataParser</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
		<script src="lib/papaparse.min.js"></script>
		<script src="nlp.js"></script>
	</head>
	<style>
		body { 	font-family:Segoe UI,Verdana,Geneva,sans-serif;font-size:16px; margin:20px; }
		.co-is 		{	border-radius:16px; padding:0 8px; height: 24px; border:1px solid #999; font-size: 13px; text-align:center; }
		.co-bs 		{	display:inline-block; border-radius:16px; padding:0 16px; border:1px solid #999; font-size: 13px; 
						cursor:pointer; z-index:2; padding-bottom:1px; color:#000; background-color: #eee; font-weight:600; }
		.co-bsg		{	cursor: pointer; color:#fff; text-align: center; border-radius: 16px; display: inline-block; user-select: none;
						font-size: 13px; background-color: #999; padding: 2px 8px 2px 8px; }
	</style>
	<body>
		<div style="width:66%;margin:0 auto;text-align:center">
			<img src="img/lizalogo.png" style="width:25%">
			<span style="font-size:24px;vertical-align:12px"><b> dataParser</b></span>
			<hr>
			Scene: <select class="co-is" id="lz-scene">
				<option>All</option><option>0</option><option>1</option>><option>2</option>
				</select>
			&nbsp &nbsp; Series: <select class="co-is" id="lz-series">
				<option>All</option><option>100</option><option>200</option><option>
				300</option><option>400</option><option>500</option>
			</select>
			&nbsp &nbsp; Use decimals? <input type="checkbox" checked id="lz-dots"/>
			&nbsp &nbsp; Number per series: <input type="input" class="co-is" style="width:40px" value="500" id="lz-num"/>
			&nbsp &nbsp; Range: <input type="input" class="co-is" style="width:40px" value="90-100" id="lz-session"/>
			<hr><p>
				<div class="co-bs" id="lz-makeTrain">Make nlu.yml</div>
				&nbsp &nbsp &nbsp;<div class="co-bs" id="lz-makeResponse">Make response</div>
				&nbsp &nbsp &nbsp;<div class="co-bs" id="lz-makeSession">Make session</div>
				&nbsp &nbsp &nbsp;<div class="co-bs" id="lz-makeStories">Make stories</div>
			</p>
			<hr>
			<p id="outp" style="text-align:left"></p>
		</div>
	
<script>

/////////////////////////////////////////////////////////////////////////////////////////////////
// APP 
/////////////////////////////////////////////////////////////////////////////////////////////////

	let rawData=[], intents=[], responses=[], keyWords=[];
	let nlp=new NLP();																				// Alloc NLP class

	$(document).ready(function() {								           						// ON PAGE LOADED
		LoadConfig();
		$("#lz-makeTrain").on("click",()=>   { MakeTrain() } );										// ON MAKE TRAINING FILE
		$("#lz-makeResponse").on("click",()=>{ MakeResponse() } );									// ON MAKE RESPONSE
		$("#lz-makeSession").on("click", ()=>{ MakeSession() } );									// ON MAKE SESSION
		$("#lz-makeStories").on("click", ()=>{ MakeStories() } );									// ON MAKE STORIES
		$(window).on("keydown",function(e) {														// HANDLE KEYPRESS
			if ((e.which == 84) && e.altKey && e.ctrlKey)	{										// Test key (Ctrl+Alt+T)
				}
			});
		});

	function LoadConfig()																		// LOAD CONFIG FILE
	{	
		let i,k,o,v,intent;
		fetch('assets/config.csv')																	// Load file
			.then(res => res.text())																// Get as text
			.then(res =>{																			// Process																	
				let data=Papa.parse(res, { header:true, skipEmptyLines:true }).data;				// Parse CSV using papa lib
				nlp.SetWho(data);																	// Set student synonyms
				LoadRawData('assets/rawData.csv');													// Load raw data file
			});
		}
	
	function LoadRawData(file)																	// LOAD RAW DATA CSV
	{
		fetch(file)																					// Load file
			.then(res => res.text())																// Get as text
			.then(res =>{																			// Process																	
				rawData=Papa.parse(res, { header:true, skipEmptyLines:true }).data;					// Parse CSV using papa lib
				GetKeyWords();																		// Get keywords
				ParseData();																		// Parse data and show stats
			});
	}

	function ParseData()																		// PARSE DATA AND SHOW DATA STATS
	{
		let i,o;
		let nRemarks=0, nResponses=0; 																// Counts
		let trigger=[];																				// Triggering teacher's remarks
		for (i=0;i<rawData.length;++i) {															// For each entry
			o=rawData[i];																			// Point at line
			if (!o.intent)	continue;																// Skip no intents
			if (o.speaker == "Teacher") {															// A remark
				if (o.text.split(" ").length < 4)	continue;										// Skip short remarks
				trigger+=o.text+" ";																// Add to response trigger text
				++nRemarks;																			// Add to count											
				if (!intents["r"+Math.floor(o.intent)]) intents["r"+Math.floor(o.intent)]=[];		// Create base intent holder
				if (!intents["r"+o.intent]) intents["r"+o.intent]=[];								// Create full holder
				intents["r"+Math.floor(o.intent)].push(i);											// Add base index
				intents["r"+o.intent].push(i);														// Add full
				}
			else{																					// A student response
				let keys=nlp.Tokenize(trigger).filter(value => keyWords.includes(value));			// Get keys mentioned
				if (!responses["r"+o.intent]) responses["r"+o.intent]=[];							// Create holder
				responses["r"+o.intent].push({ trigger:trigger, keys: keys, text: o.text, actor:o.speaker, intent:o.intent });	// Add to list
				trigger=[];																			// Reset trigger
				++nResponses;																		// Add response
				}
			}
		
		let str=`<table>
		<tr><td><b>Number of remarks</b>:</td><td>${nRemarks}</td></tr>
		<tr><td><b>Number of responses</b>: &nbsp; </td><td>${nResponses}</td></tr>`
		str+=getIntents()+"</table>";																// Get number of intents
		$("#outp").html(str.replace(/\t|\n|\r/g,""));												// Show stats

		function getIntents() {																		// GET INTENTS
			let i,j,s="";
			for (i=0;i<1000;i+=10) 																	// For each intent
				if (intents["r"+i]) 																// If it exists	
					s+=`<tr><td><b>Intent ${i}</b>:</td><td>${intents["r"+i].length}</td><td>${getSubIntents(i)}</td></tr>`;
			return s;																				// Return intent line
			}

		function getSubIntents(base) {																// GET NUMBER OF SUB INTENTS
			let i,s="( &nbsp;";
			for (i=1;i<10;++i) 																		// For for subs
				if (intents["r"+base+"."+i]) 														// If it exists	
					s+=i+"="+intents["r"+base+"."+i].length+" &nbsp;";								// Add to string
			return s+")";																			// Return subs
			}
	}		

	function GetKeyWords()																		// GET UNIQUE LIST OF WORDS
	{
		let i,j,k,v;
		keyWords=[];																				// Clear array
		for (i=0;i<rawData.length;++i) {															// For each line
			v=nlp.Tokenize(rawData[i].text);														// Tokenize line
			for (j=0;j<v.length;++j) 																// For each word															
				if (v[j].length > 3)																// If big enough	
					keyWords.push(v[j]);															// Add to key word list	
			}
		keyWords=[... new Set(keyWords)];															// Make unique
	}

/////////////////////////////////////////////////////////////////////////////////////////////////
// OUTPUT 
/////////////////////////////////////////////////////////////////////////////////////////////////

	function MakeTrain()																		// CREATE TRAINING YML FILE
	{
		let i,k,o,base;
		let str="version: \"2.0\"\n\nnlu:\n";
		let series=$("#lz-series").val();															// Series to use
		let scene=$("#lz-scene").val();																// Scene to use
		let session=$("#lz-session").val().split("-");												// Session to skip
		let sa=session[0],se=session[1];															// Extract range
		if (!se) se=sa+1;																			// Just one
		let num=$("#lz-num").val();																	// Number to use
		let dots=$("#lz-dots").prop("checked");														// Sub intents?

		for (k in intents) {																		// For each one
			if (!k || (k == 0))				continue;												// Skip unecoded intents
			if (series == "All") {																	// Adding them all
				if (!dots && k.match(/\./)) continue;												// Skip decimals
				if (dots && !k.match(/\./)) continue;												// Skip whole numbers
				if (dots) 					base=k.substr(1);										// Top entry - whole
				else 	  					base=Math.floor(k.substr(1));							// Top decimal
				str+="- intent: r"+base+"\n  examples: |\n";										// Add header
				str+=addIntent("r"+base);															// Add items
				}
			else if (series == Math.floor(k.substr(1)/100)*100)	{									// Adding individually from a series
				if (!dots && k.match(/\./)) continue;												// Skip decimals
				if (dots && !k.match(/\./)) continue;												// Skip whole numbers
				if (dots) base=k.substr(1);															// Top entry - whole
				else 	  base=Math.floor(k.substr(1));												// Top decimal
				str+="- intent: r"+base+"\n  examples: |\n";										// Add header
				str+=addIntent("r"+base);															// Add items
				}
			}
		SaveTextAsFile("nlu.yml",str);																// Write file
		Sound("ding");																				// Sound	
		return str;																					// Return data

		function addIntent(k) {																		// ADD INTENT TO NLU
			let i,o,n=0,s="",re,ss,who;
			for (i=0;i<intents[k].length;++i) {														// For each one
				o=rawData[intents[k][i]];															// Point at item
				if ((o.rerid-0 >= sa-0) && (o.rerid-0 < se-0)) continue;							// An excluded one
				ss=o.text;																			// Point at text
				who=nlp.GetWho(o.text);																// Get who
				if (who) {																			// Got one
					re=new RegExp(`\\b${who.split(":")[0]}\\b`,"i");								// Make regex
//					ss=ss.replace(re,`[${who.split(":")[1]}](student)`);							// Encode entity
					ss=ss.replace(re,"STUDENT");													// Encode entity
					}
				s+="        - "+ss.trim()+"\n";														// Add remark
				n++;																				// Advance count
				if (n > num)	break;																// Only so many
				}
			return s;																				// Return intents group
			}
	}

	async function MakeSession()																// CREATE SESSION FILE
	{
		let i,o,session=[],texts=[];
		let fields=["scene","actor","code","calc","text"];											// Field names
		let teacher=$("#lz-session").val().split("-")[0];											// Teacher to add
			for (i=0;i<rawData.length;++i) {														// For each line
			o=rawData[i];																			// Point at it
			if (o.rerid != teacher) 	continue;													// Skip if not right teacher
			if (!o.intent)				continue;													// Skip if not coded																			
			texts.push(o.text);																		// Add to array of texts
			session.push({ scene:o.topic, actor:o.speaker, code:o.intent, calc:0, text:o.text });		// Add line 
			}
		
		const fetchAll=async(texts) => {															// GET ALL INTENTS AT ONCE
  			let i,n;
			const res   = await Promise.all(texts.map(t => GetResponse(t)));						// Ask for intents
  			const jsons = await Promise.all(res.map(r => r.json()));								// Wait for them
			for (i=0;i<jsons.length;++i) {															// For each line
				n=(jsons[i].intent_ranking[0].name == "nlu_fallback") ? 1 : 0;						// Go to second choice
				session[i].calc=jsons[i].intent_ranking[n].name.substr(1);							// Get intent
				}
			let str=Papa.unparse(session,{ header:true, skipEmptyLines:true, columns:fields });		// Make CSV using lib
			SaveTextAsFile("session-"+teacher+".csv",str);											// Write file
			Sound("ding");																			// Sound
			}
		fetchAll(texts);																			// Get all intents
	}

	function MakeResponse()																		// MAKE RESPONSE FILE
	{
		let i,k,n,resp=[];
		let fields=["intent","actor","keys","trigger","text"];										// Field names
		let series=$("#lz-series").val();															// Series to use
		let scene=$("#lz-scene").val();																// Scene to use
		let num=$("#lz-num").val();																	// Number to use
		for (k in responses) {
			if ((series == "All") || (Math.floor(k.substr(1)/100)*100 == series)) {					// If one I want
				n=0;																				// Reset counter
				for (i=0;i<responses[k].length;++i)													// For each response
					if (n++ < num)																	// Within count
						resp.push(responses[k][i]);													// Add to file
				}
			}
		let str=Papa.unparse(resp,{ header:true, skipEmptyLines:true, columns:fields });			// Make CSV using lib
		SaveTextAsFile("responses-"+series+".csv",str);												// Write file
		Sound("ding");																				// Sound
	}

	function GetResponse(msg)																	// GET RESPONSE FROM AI
	{
		return fetch("https://lizasim.com:5005/model/parse", {										// Fetch data
			method:"POST",
			body: JSON.stringify({text:msg})		
			})
		}

	function MakeStories()																		// MAKE ALL FILES FOR STORIES
	{
		let ints=[],doms=[],sess=[];
		let i,k,o,ss,re,who,id,sid;
		let session=$("#lz-session").val().split("-");												// Session to skip
		let start=session[0],end=session[1];														// Extract range
		if (!end) end=start-0+1;																	// Just one
		let dots=$("#lz-dots").prop("checked");														// Sub-intents?
		for (i=0;i<rawData.length;++i) {															// For each line
			o=rawData[i];																			// Point at it
			if (!o.intent)									continue;								// Skip if not coded																			
			if ((o.rerid < start-0) || (o.rerid > end-0))	continue;								// Skip if not in set
			if (dots) id="r"+o.intent;																// Make fuull intent id name
			else	  id="r"+Math.floor(o.intent);													// Just the whole numbers					
			sid="session-"+o.rerid;																	// Session id
			if (!sess[sid]) sess[sid]=[];															// Alloc session holder
			if (!ints[id]) 					 ints[id]=[];											// Alloc intent holder
			if (o.speaker == "Teacher") {															// If remark
				sess[sid].push("  - intent: "+id+"\n");												// Add intent to story
				ss=o.text;																			// Point at text
				who=nlp.GetWho(o.text);																// Get who
				if (who) {																			// Got one
					re=new RegExp(`\\b${who.split(":")[0]}\\b`,"i");								// Make regex
					ss=ss.replace(re,"STUDENT");													// Encode entity
					}
				ints[id].push("        - "+ss.trim()+"\n");											// Add it
				}
			else{																					// Response
				sess[sid].push("  - action: utter_r"+i+"\n");										// Add response to story
				doms.push(`\n  utter_r${i}:\n  - text: "${o.text.trim()}"\n`);						// Add to domain file							
				}
			}
	
		let str="version: \"2.0\"\n\nnlu:\n";														// NLU header
		for (k in ints)	{																			// For each intent
			str+="- intent: "+k+"\n  examples: |\n";												// Add header
			for (i=0;i<ints[k].length;++i) 	str+=ints[k][i];										// Add each remark in intent group
			}
		SaveTextAsFile("nlu.yml",str);																// Write file
		str="version: \"2.0\"\n\nstories:\n";														// Stories header
		for (k in sess)	{																			// For each intent
			str+="\n- story: "+k+"\n  steps:\n";													// Add header
			for (i=0;i<sess[k].length;++i) 	str+=sess[k][i];										// Add each remark in intent group
			}
		SaveTextAsFile("stories.yml",str);															// Write file
		str="version: \"2.0\"\n\nsession_config:\n";												// Stories header
		str+="  session_expiration_time: 60\n  carry_over_slots_to_new_session: true\n\nintents:\n";
		for (k in ints)	str+="  - "+k+"\n";															// Add intent
		str+="\nresponses:\n";																		// Responses header	
		for (i=0;i<doms.length;++i) 	str+=doms[i];												// Add each remark in intent group
		SaveTextAsFile("domain.yml",str);															// Write file
		Sound("ding");																				// Sound	
	}


/////////////////////////////////////////////////////////////////////////////////////////////////
// HELPERS 
/////////////////////////////////////////////////////////////////////////////////////////////////

	function trace(msg, p1, p2, p3, p4)																// CONSOLE 
	{
		if (p4 != undefined)
			console.log(msg,p1,p2,p3,p4);
		else if (p3 != undefined)
			console.log(msg,p1,p2,p3);
		else if (p2 != undefined)
			console.log(msg,p1,p2);
		else if (p1 != undefined)
			console.log(msg,p1);
		else
			console.log(msg);
	}

	function Sound(sound, mute)																		// PLAY SOUND
	{
		var snd=new Audio();																			// Init audio object
		if (sound.match(/\.mp3/i))		snd=new Audio(sound)											// If an MP3 file
		else							snd=new Audio("img/"+sound+".mp3");								// Use built in mp3
		if (!mute)	{																					// If not initing or muting	
			snd.volume=100/100;																			// Set volume
			snd.play();																					// Play it
			}
		}

	function SaveTextAsFile(file, contents)															// SAVE TEXT TO LOCAL FILE
	{
		if (file.charAt(0) == "*") {																	// If asking
			GetTextBox("Type file name","", file.substr(1), (s)=>{ SaveTextAsFile(s, contents); });		// Ask for name
			return;																						// Quit
			}
		var textFileAsBlob=new Blob([contents], {type:'text/plain'});
		var downloadLink=document.createElement("a");
		downloadLink.download=file;
		downloadLink.innerHTML="Download File";
		downloadLink.href=window.URL.createObjectURL(textFileAsBlob);
	    downloadLink.onclick=()=>{ downloadLink.remove(); };
		downloadLink.style.display="none";
		downloadLink.id="tdll";
		document.body.appendChild(downloadLink);
		downloadLink.click();
	}

</script>
</body>
</html>

